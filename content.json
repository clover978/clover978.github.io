{"meta":{"title":"clover978","subtitle":"","description":"","author":"clover978","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2021-01-06T01:11:33.000Z","updated":"2021-01-06T01:12:35.121Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-01-06T01:12:03.000Z","updated":"2021-01-06T01:12:33.378Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Python 编写 C 扩展","slug":"Python-20210107-Python-编写-C-扩展","date":"2021-01-07T03:07:56.000Z","updated":"2021-01-07T03:09:16.519Z","comments":true,"path":"2021/01/07/Python-20210107-Python-编写-C-扩展/","link":"","permalink":"http://example.com/2021/01/07/Python-20210107-Python-%E7%BC%96%E5%86%99-C-%E6%89%A9%E5%B1%95/","excerpt":"Python 编写 C/C++ 扩展Python 的特性使得其在编写大型项目的时候并不占优势，目前主流的项目代码还是用C/C++或Java编写的，为了让我们写的Python代码能够嵌入到项目中，一般有两种方式，1）让Python操作数据库，相当于通过读数据库完成传参，写数据库实现结果返回；2）使用Python嵌入式编程，操作数据库的方式相对简单，但是存在一些问题，例如，主程序需要监听Python代码的返回值、数据库的权限需要暴露给模块、每一个模块都需要变为一个单独的服务常驻进程，相比之下，嵌入式编程的方式更加优雅，只需要将Python代码编写成 DLL/.so 文件提供给主程序，主程序直接调用就可以，这种过程的一个副产物就是可以保护源代码。下面记录一次在Windows上使用Python嵌入式编程的实战过程，主要包含 工具准备，创建DLL，调用DLL，变量类型优化，依赖解决五个部分","text":"Python 编写 C/C++ 扩展Python 的特性使得其在编写大型项目的时候并不占优势，目前主流的项目代码还是用C/C++或Java编写的，为了让我们写的Python代码能够嵌入到项目中，一般有两种方式，1）让Python操作数据库，相当于通过读数据库完成传参，写数据库实现结果返回；2）使用Python嵌入式编程，操作数据库的方式相对简单，但是存在一些问题，例如，主程序需要监听Python代码的返回值、数据库的权限需要暴露给模块、每一个模块都需要变为一个单独的服务常驻进程，相比之下，嵌入式编程的方式更加优雅，只需要将Python代码编写成 DLL/.so 文件提供给主程序，主程序直接调用就可以，这种过程的一个副产物就是可以保护源代码。下面记录一次在Windows上使用Python嵌入式编程的实战过程，主要包含 工具准备，创建DLL，调用DLL，变量类型优化，依赖解决五个部分 工具准备1. MinGW网上的很多教程使用 VS 编写 DLL，鉴于 VS 安装过程太麻烦，并且还不能跨平台，这里选择的编译器是 GCC，直接在 MinGW-W64 官网上下载安装程序就可以了（不要在 minGW 官网上下载，在线安装过程会不断 fail），安装完了之后需要做两件事： 121. 将 MinGW 的 bin 目录加入环境变量2. 在 bin 目录下建立软链接，make -&gt; mingw32-make 安装成功之后可以在命令行使用gcc, make这两个命令 2. Cython这个很简单，只需要 pip install cython 就安装好了，安装成功可以在命令行使用 cython命令 创建 DLL1. Python 源文件这次封装的 Python 代码源文件如下 12345678910111213141516171819202122# Y_interpoldate.pyimport pandas as pdimport numpy as npfrom scipy.interpolate import griddataimport osos.environ[&#x27;PROJ_LIB&#x27;] = r&#x27;D:\\Softwares\\Anaconda3\\pkgs\\proj4-4.9.3-hcf24537_7\\Library\\share&#x27;from mpl_toolkits.basemap import Basemapdef load_data(csv_name): return pd.read_csv(csv_name, header=None, names=[&#x27;lons&#x27;,&#x27;lats&#x27;,&#x27;values_&#x27;])def interpolate(): data = load_data(&#x27;HG.csv&#x27;) basemap = Basemap(projection=&#x27;ortho&#x27;,lat_0=30,lon_0=120) x, y = basemap(data.lons.values, data.lats.values) xi = np.linspace(min(x)*0.8, max(x)*1.2, 300) yi = np.linspace(min(y)*0.8, max(y)*1.2, 300) X, Y = np.meshgrid(xi, yi) Z = griddata( (x,y), data.values_, (X,Y), method=&#x27;linear&#x27; ) print(X.shape, Y.shape, Z.shape) 需要封装的函数是 interpolate，为了简单起见，函数没有设置入参和返回值，在动态变量类型优化部分会深入讨论 2. Cython 编译第一步用 Cython 编译源文件，Cython 编译的源文件是 .pyx 格式，Cython中定义导出函数的格式如下： 12345cdef public PyObject* func(PyObject* argv, ...)# cdef： 是 Cython 定义函数的关键字； # public： 代表函数是要被导出的； # void： 指定函数的返回类型。 因此将源文件需要导出的函数进行下面的改动并另存为 .pyx 文件 123# _Y_interpolate.pyxcdef public void _interpolate(): ... 使用如下命令编译 .pyx文件生成 .c, .h 文件 1cython _Y_interpolate.pyx 在生成的头文件中可以找到两个函数： 1234__PYX_EXTERN_C void _interpolate(void);PyMODINIT_FUNC init_Y_interpolate(void); //for py2PyMODINIT_FUNC PyInit__Y_interpolate(void); //for py3 注意这里另存的 .pyx 文件名和 函数名 前面都添加了一个 _，在之后会解释。 2.5 生成 exe 文件生成 _Y_interpolate.c 和 _Y_interpolate.h 文件后，就可以直接利用这两个源文件编写 C 程序了 123456789101112// cppmain.c#include &quot;Python.h&quot;#include &quot;_Y_interpolate.h&quot; int main(int argc, char *argv[])&#123; Py_Initialize(); PyInit__Y_interpolate(); _interpolate(); Py_Finalize(); return 0;&#125; 编译命令 1234gcc _Y_interpolate.c cppmain.c -m64 -mthreads -Wall -O3 \\-I. -ID:\\Softwares\\Anaconda3\\include \\-LD:\\Softwares\\Anaconda3\\Lib -LD:\\Softwares\\Anaconda3\\ -lpython36 -o cppmain 可以看见直接调用的程序还比较麻烦，需要使用 Py_Initialize() 和 Py_Finalize() 包裹代码，而且使用函数之前还需要一次初始化(注意这里的初始化函数 python2 和 python3 有区别，例子是 py3 的写法)。下面看看 DLL 封装是怎么做的吧。 3 生成 DLL 文件编写下面的 DLL 主程序代码 1234567891011// Y_interpolate.h#ifndef Y_interpolate_H#define Y_interpolate_H#ifdef BUILD_DLL __declspec(dllexport) void interpolate(void);#else __declspec(dllimport) void interpolate(void);#endif#endif 1234567891011121314151617181920212223//Y_interplate.c#include &lt;Python.h&gt;#include &lt;Windows.h&gt;#include &quot;Y_interpolate.h&quot;// 定义DLL导出函数 interpolate()，如果没有这一步，同样可以生成 dll，但是符号表中找不到 _interpolate()__declspec(dllexport) void __stdcall interpolate() &#123; return _interpolate();&#125;//将 Python 初始化的代码封装到 DLL 的主函数中BOOL WINAPI DllMain(HINSTANCE hinstDLL,DWORD fdwReason,LPVOID lpReserved) &#123; switch( fdwReason ) &#123; case DLL_PROCESS_ATTACH: Py_Initialize(); PyInit_Y_interpolate(); break; case DLL_PROCESS_DETACH: Py_Finalize(); break; &#125; return TRUE;&#125; 编译命令： 12345gcc _Y_interpolate.c Y_interpolate.c Y_interpolate.h \\-DBUILD_DLL -shared -m64 -Wall -O3 \\-I. -ID:\\Softwares\\Anaconda3\\include \\-LD:\\Softwares\\Anaconda3\\Lib -LD:\\Softwares\\Anaconda3\\ \\-lpython36 -o Y_interpolate.dll -Wl,--output-def,Y_interpolate.def,--out-implib,Y_interpolate.a 可以看见，Y_interplate.c 中的代码就是将 Cython 生成的 _Y_interplate.c 进行了一次封装，第一，将函数接口封装成 DLL导出函数；第二，将 Python 初始化相关的代码封装到DLL的加载主函数中（这就是之前 Cython 生成 .c 文件时最好修改一下文件名和函数接口的原因）。编译的时候 -Wl 选项后面的内容指定编译器同时生成了 def 文件和 .a 文件，这两个文件一般是用来存放代码中的函数表的，实际上，目前调用的时候并不需要这两个文件 调用 DLL生成好 DLL 后，就可以编写 C 程序来调用了，看一下调用的代码 12345678&#x2F;&#x2F;dllcall.c#include &quot;Y_interpolate.h&quot;int main()&#123; interpolate(); return 0;&#125; 编译命令： 1gcc dllcall.c -m64 -mthreads -Wall -O3 -I. -L. -lY_interpolate -o dllcall 不需要解释，无论是程序代码编写还是编译命令都非常优雅简洁，没有任何冗余。只需要一个 .h 文件和 dll 文件，就可以让其他程序调用 interpolate 这个接口（实际上，即使没有头文件，程序也可以编译成功，只是会出现 warning）。 变量类型优化实际项目中，混合编程大多数都是需要传递参数的，由于这一部分比较复杂，因此在上面的例子中导出函数入参和返回值都设计为 void，下面详细讲解 Python 混合编程的时候怎样传参。众所周知，Python 中的变量是动态变量，不需要显式声明就可以直接使用，而 C/C++ 中的变量都是静态变量，因此传参的过程必然需要转换，转换例子可以参看 Python 官方的例子 1234567891011121314151617&#x2F;&#x2F; 1.1 转换入参 C-&gt;PyObject，构造包含3个元素的数组PyObject* args &#x3D; PyTuple_New(3);PyObject* arg1 &#x3D; Py_BuildValue(&quot;i&quot;, 100); &#x2F;&#x2F; 整数参数PyObject* arg2 &#x3D; Py_BuildValue(&quot;f&quot;, 3.14); &#x2F;&#x2F; 浮点数参数PyObject* arg3 &#x3D; Py_BuildValue(&quot;s&quot;, &quot;hello&quot;); &#x2F;&#x2F; 字符串参数PyTuple_SetItem(args, 0, arg1);PyTuple_SetItem(args, 1, arg2);PyTuple_SetItem(args, 2, arg3);&#x2F;&#x2F; 1.2 与上面等价PyObject* args &#x3D; Py_BuildValue(&quot;(ifs)&quot;, 100, 3.14, &quot;hello&quot;);&#x2F;&#x2F; 2 调用函数PyObject* pRet &#x3D; PyObject_CallObject(pv, args);&#x2F;&#x2F; 3. 转换返回值 PyObject-&gt;C，类似函数还有 PyFloat_AsDouble,PyString_AsString,PyArg_ParseTuple 等long res &#x3D; PyInt_AsLong(pRet); 例程中的转换分别使用了 Py_BuildValue，PyInt_AsLong两个接口，这都是 Python.h 中定义的函数，用这些操作去构造数组无疑是繁琐且效率低下的，那么可不可以避免这些操作呢。答案是可以的，我们可以在 Cython 编译 pyx文件的时候告诉它入参和返回值的类型，这样调用方就可以像调用C语言的函数一样调用导出的函数了，由于使用了静态类型，这样做的一个副产物就是可以提高Python代码的效率。 123456789101112131415161718192021222324252627# _Y_interpolate.pyxcdef public void _interpolate(float in_arr[][3], float out_arr[][3], int in_size, int out_size): cdef np.npy_intp in_dims[2] cdef np.npy_intp out_dims[2] in_dims = &#123;in_size,3&#125; py_in_arr = np.PyArray_SimpleNewFromData(2, in_dims, np.NPY_FLOAT, &lt;void*&gt; in_arr) out_dims = &#123;out_size,3&#125; py_out_arr = np.PyArray_SimpleNewFromData(2, out_dims, np.NPY_FLOAT, &lt;void*&gt; out_arr) py_interpolate(py_in_arr, py_out_arr, out_size)def py_interpolate( np.ndarray[float, ndim=2, mode=&quot;c&quot;] in_arr not None, np.ndarray[float, ndim=2, mode=&quot;c&quot;] out_arr not None, int out_size): data = pd.DataFrame(in_arr, columns=[&#x27;lons&#x27;,&#x27;lats&#x27;,&#x27;values_&#x27;]) _min, _max = data.values_.min(), data.values_.max() data[&#x27;norm_values_&#x27;] = data.values_.apply(lambda x: x-_min/_max) basemap = Basemap(projection=&#x27;ortho&#x27;,lat_0=30,lon_0=120) x, y = basemap(data.lons.values, data.lats.values) xi = np.linspace(min(x)*0.8, max(x)*1.2, 300) yi = np.linspace(min(y)*0.8, max(y)*1.2, 300) X, Y = np.meshgrid(xi, yi) Z = griddata( (x,y), data.norm_values_, (X,Y), method=&#x27;linear&#x27;) res = np.stack([X.flatten(), Y.flatten(), Z.flatten()], axis=1) res = np.delete(res, np.where(np.isnan(res))[0], axis=0) out_arr[...] = res[:out_size,:] 这里我们使用了 numpy 的 PyArray_SimpleNewFromData() 接口将 C 语言的数组转换为 numpy.ndarray, 相反的操作可以通过 PyArray_DATA()返回数组指针，但是由于二维数组的指针的特殊性，本例没有选择使用指针作为返回值。利用 cython 编译 pyx 文件后，生成 .c,.h文件，同样可以直接使用源文件或者编译成动态链接库，这里给出通过源文件使用接口的示例 1234567891011121314151617181920212223#include &quot;Python.h&quot;#include &quot;_Y_interpolate.h&quot;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;void read_csv(float arr[][3], int line_cnt);int main(int argc, char *argv[])&#123; int in_size &#x3D; 48000, out_size &#x3D; 48000; float in_arr[in_size][3], out_arr[out_size][3]; read_csv(in_arr, in_size); Py_Initialize(); PyInit__Y_interpolate(); _interpolate(in_arr, out_arr, in_size, out_size); Py_Finalize(); printf(&quot;%f, %f, %f&quot;, out_arr[1][0], out_arr[1][1], out_arr[1][2]); return 0;&#125; 编译命令为： 12345gcc _Y_interpolate.c cppmain.c -m64 -mthreads -Wall -O3 \\-I. -ID:\\Softwares\\Anaconda3\\include -ID:\\Softwares\\Anaconda3\\lib\\site-packages\\numpy\\core\\include \\-LD:\\Softwares\\Anaconda3\\ -LD:\\Softwares\\Anaconda3\\Lib \\-lpython36 -o examples\\cppmain# 注意需要引用 numpy 的头文件 至此，在 Cython 的帮助下，我们终于完成了一个 Python 代码的封装，熟悉这个步骤，就可以在实际项目中很轻松地利用 Python 进行开发了，利用运行效率换取开发效率。 依赖解决0. 依赖问题试试运行按照上面步骤生成的 exe 文件，可能会出现提示 找不到 Y_interpolate.dll，将生成的 Y_interpolate.dll 文件复制到当前文件夹下，继续报错 找不到 python36.dll，同样将 python36.dll 复制到当前文件夹下。同时发布这三个文件，程序可以启动，但是并不一定能运行，如果电脑上的 Anaconda 被卸载，程序启动后会提示错误 12Fatal Python error: Py_Initialize: unable to load the file system codecModuleNotFoundError: No module named &#39;encodings&#39; 显然这是 Python 的各种包引发的问题，那么怎么把程序中用到的 Python 包都打包到新的环境中呢？ 0.5 用户安装依赖最简单解决依赖的方法就是在用户的计算机上安装 Python，然后通过 pip 安装需要的依赖，这种方法只需要建立虚拟环境，然后使用 pip freeze, conda env export 等命令就可以完成。这种方法虽然简单，但是对于用户来说也更容易出错，有没有什么办法可以让开发者把所有依赖都打包都一个文件夹或打包成一个文件的方法呢。下面介绍两种可行的方法。 1. PyinstallerPyinstaller 是一个将 Python 代码编译成 EXE 文件的工具，类似的工具还有 cx_freeze,py2exe, 这些工具生成 exe 时，会同时将 exe 所需要的依赖打包到一个文件夹中，将这个文件夹与生成的 DLL 一起发布，就可以解决依赖问题。 尝试到一半，打包的体积有点儿大，网上有很多相关讨论，时间问题没有继续试验 2. 虚拟环境这个方法与 0.5 中介绍的方法有些相似，只是不需要用户自己安装了。 12345# 首先创建虚拟环境conda create -n dependency python=3.6conda activate dependencypip install numpy pandas scipy matplotlib ... 安装完毕后，用户需要的依赖就全部都在 123D:\\Softwares\\Anaconda3\\envs\\dependency\\DLLs\\D:\\Softwares\\Anaconda3\\envs\\dependency\\Lib\\D:\\Softwares\\Anaconda3\\envs\\dependency\\Lib\\site-packages\\ 这个三个目录里面了,运行时候将 PYTHONPATH 指向这三个子目录 或者 set PYTHONHOME=D:\\Softwares\\Anaconda3\\envs\\dependency 就可以成功运行程序了。因此我们可以在 C 程序中加入如下代码 1234567wchar_t* py_home = Py_GetPythonHome();printf(&quot;%S&quot;, py_home);if(py_home==NULL)&#123; Py_SetPythonHome(L&quot;./dependency&quot;);&#125;Py_Initialize();...... 这样就可以将 Python 所需要的依赖打包给用户，用户用 PYTHONHOME 环境变量或者 .pth 文件指定依赖的位置，或者直接放在 exe 所在目录即可。（注意路径中不要出现中文字符） 扩展阅读 pyinstaller 打包 pandas cython 编译 pyd boost-python swig protocol buffer","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"动态链接库","slug":"动态链接库","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"混合编程","slug":"混合编程","permalink":"http://example.com/tags/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"}]},{"title":"argparser 模块","slug":"Python-20210107-argparser-模块","date":"2021-01-07T03:05:37.000Z","updated":"2021-01-07T03:07:00.629Z","comments":true,"path":"2021/01/07/Python-20210107-argparser-模块/","link":"","permalink":"http://example.com/2021/01/07/Python-20210107-argparser-%E6%A8%A1%E5%9D%97/","excerpt":"Command line parseargpaser 是 Python 官方推荐的 命令行参数解析器，习惯使用它可以极大地方便 Python程序的交互。","text":"Command line parseargpaser 是 Python 官方推荐的 命令行参数解析器，习惯使用它可以极大地方便 Python程序的交互。 Example1234567import argparseargs &#x3D; argparse.ArgumentParser(descroption&#x3D;&#39;Argpase example&#39;)args.add_argument(&#39;first&#39;, type&#x3D;str, help&#x3D;&#39;first argument&#39;)args &#x3D; args.parse_args()print(args.fisrt) 必选参数1args.add_argument(&#39;first&#39;, type&#x3D;str, help&#x3D;&#39;first argument&#39;) 可选参数1args.add_argument(&#39;--optional&#39;, type&#x3D;str, help&#x3D;&#39;first argument&#39;) action1args.add_argument(&#39;--action_1&#39;, action&#x3D;&#39;store_true&#39;, help&#x3D;&#39;action_1 is True&#39;)","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"argparser","slug":"argparser","permalink":"http://example.com/tags/argparser/"}]},{"title":"Python 多线程","slug":"Python-20210107-Python-多线程","date":"2021-01-07T03:03:36.000Z","updated":"2021-01-07T03:04:14.742Z","comments":true,"path":"2021/01/07/Python-20210107-Python-多线程/","link":"","permalink":"http://example.com/2021/01/07/Python-20210107-Python-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"0. Intro多线程/多进程 在执行 IO密集型 或者 CPU密集型 的任务时，能够大大提高效率。Python 实现 多线程/多进程 的方式有很多，这里列举几个我见过的。 thread/threading/Queue ： Python 官方库，接口比较简单 multiprocessing concurrent ：对 Threading 进一步封装 joblib","text":"0. Intro多线程/多进程 在执行 IO密集型 或者 CPU密集型 的任务时，能够大大提高效率。Python 实现 多线程/多进程 的方式有很多，这里列举几个我见过的。 thread/threading/Queue ： Python 官方库，接口比较简单 multiprocessing concurrent ：对 Threading 进一步封装 joblib 多线程是一个看起来很复杂，但是实际学习使用很简单的一个东西，所以当你有并发运算的需求的时候，一定要勤于动手，使用多线程/多进程去实现，这样会节省很多时间。关于多线程与多进程的选择，一般的原则是 IO 密集型任务使用多线程， CPU密集型任务使用多进程，Python3 中好像还有 协程 的概念，属于比线程更加细粒度的并发，暂时没有研究过。这篇文章主要记录 concurrent 库的简单使用。 Python2 中需要安装 future 库，Python3 的官方库中已经包含。 concurrentconcurrent 的接口非常简单： 12345678910111213141516171819202122232425262728def print_job(obj): print(obj) return obj from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, Executorimport time# 多线程s = time.time()with ThreadPoolExecutor(max_workers=8) as pool: results = list( pool.map(print_job, range(100000)) )t1 = (time.time()-s)# 多进程s = time.time()with ProcessPoolExecutor(max_workers=8) as pool: results = list( pool.map(print_job, range(100000)) )t2 = (time.time()-s)# 循环s = time.time()for i in range(100000): print_job(i)t3 = (time.time()-s)print(t1, t2, t3)8.888239145278937.6266052722930912.69059157371521 由于举了一个 非IO密集型，非 CPU 密集型 的例子，所以结果非常尴尬。总之，Python 的并发编程接口就是这样的。","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Python 中的 configure 设计","slug":"Python-20210107-Python-中的-configure-设计","date":"2021-01-07T03:02:06.000Z","updated":"2021-01-07T03:05:51.383Z","comments":true,"path":"2021/01/07/Python-20210107-Python-中的-configure-设计/","link":"","permalink":"http://example.com/2021/01/07/Python-20210107-Python-%E4%B8%AD%E7%9A%84-configure-%E8%AE%BE%E8%AE%A1/","excerpt":"Build configure file for you project作为程序员，配置文件的作用和必要性无需赘言，很多优秀的开源项目也会配备一个 config 文件，下面介绍一些常见的 config 方法","text":"Build configure file for you project作为程序员，配置文件的作用和必要性无需赘言，很多优秀的开源项目也会配备一个 config 文件，下面介绍一些常见的 config 方法 Python 脚本Python 脚本是一种简单的配置方法。这种方法适用于一些自己写的小工程，一来它安全性不高，二来违背了配置与代码解耦的原则。 123456789101112131415161718192021############################################# databaseconfig.py#############################################!/usr/bin/env pythonimport preprocessingmysql = &#123;&#x27;host&#x27;: &#x27;localhost&#x27;, &#x27;user&#x27;: &#x27;root&#x27;, &#x27;passwd&#x27;: &#x27;my secret password&#x27;, &#x27;db&#x27;: &#x27;write-math&#x27;&#125;preprocessing_queue = [preprocessing.scale_and_center, preprocessing.dot_reduction, preprocessing.connect_lines]use_anonymous = True############################################# main.py#############################################!/usr/bin/env pythonimport databaseconfig as cfgconnect(cfg.mysql[&#x27;host&#x27;], cfg.mysql[&#x27;user&#x27;], cfg.mysql[&#x27;password&#x27;]) YAML 文件 yaml 文件也是一种很流行的配置方法，相比于使用 Python 脚本，部署的时候， yaml 文件可以做到与代码解耦，因此更友好。相比于 json 文件，yaml 文件更易于阅读修改，除非有特殊需求，一般情况使用 yaml 文件配置工程是很好的选择。 1234567891011121314151617181920212223242526272829####################### databaseconfig.yml######################mysql: host: localhost user: root passwd: my secret password db: write-mathother: preprocessing_queue: - preprocessing.scale_and_center - preprocessing.dot_reduction - preprocessing.connect_lines use_anonymous: yes####################### main.py######################import yamlwith open(&quot;config.yml&quot;, &#x27;r&#x27;) as ymlfile: cfg = yaml.load(ymlfile)for section in cfg: print(section)print(cfg[&#x27;mysql&#x27;])print(cfg[&#x27;other&#x27;]) yaml 文件里面还可以指定 item 的数据类型数据类型对应表 1234video_size: !!python/tuple [1280, 720] # 注意后面是中括号stride: 300history: 10mask_n: 10 configparserconfigparser 是 Python 的一个模块。","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"namedtuple 模块","slug":"Python-20210107-namedtuple-模块","date":"2021-01-07T02:57:47.000Z","updated":"2021-01-07T02:58:26.516Z","comments":true,"path":"2021/01/07/Python-20210107-namedtuple-模块/","link":"","permalink":"http://example.com/2021/01/07/Python-20210107-namedtuple-%E6%A8%A1%E5%9D%97/","excerpt":"Namedtuple: A useful data structure for explicit codingnamedtuple 是 collections 包中的一个数据结构，可以很方便的存储从 csv, 数据库 中读取到的数据，这种数据的特点是，数据分为多条记录，每一条记录包含若干字段。","text":"Namedtuple: A useful data structure for explicit codingnamedtuple 是 collections 包中的一个数据结构，可以很方便的存储从 csv, 数据库 中读取到的数据，这种数据的特点是，数据分为多条记录，每一条记录包含若干字段。 下面以一个班级学生的成绩表为例讲解一下，成绩表中包含 学号，姓名，成绩 三个字段 list/dict 存储如果对 Python 的各种数据类型接触不多，很容易会选择使用 list 或者 dict 去存储。 12345678910111213141516171819202122232425262728293031323334353637raw_data = [ [ 01, &#x27;jack&#x27;, &#x27;80&#x27;], [ 02, &#x27;mike&#x27;, &#x27;82&#x27;], [ 03, &#x27;mary&#x27;, &#x27;96&#x27;],]list_sheet = []for record in raw_data: list_sheet.append(record)# 这种方法的缺点是，每一条记录的各个字段具有什么含义并不清晰# 列表嵌字典dict_sheet = []dict_record = &#123; &#x27;stu_id&#x27;: None, &#x27;name&#x27;: None, &#x27;score&#x27;: None&#125;for record in raw_data: _id, _name, _score = record dict_record[&#x27;stu_id&#x27;] = _id dict_record[&#x27;name&#x27;] = _name dict_record[&#x27;score&#x27;] = _score dict_sheet.append(dict_record) # 字典嵌列表 dict_sheet2 = &#123; &#x27;stu_id&#x27;: [], &#x27;name&#x27;: [], &#x27;score&#x27;: [],&#125;for record in raw_data: _id, _name, _score = record dict_sheet2[&#x27;stu_id&#x27;].append(_id) dict_sheet2[&#x27;name&#x27;].append(_name) dict_sheet2[&#x27;score&#x27;].append(_score)# 这两种方法代码写起来比较麻烦，而且如果字典的 value 是 tuple/list 类型理解起来会有一些困难 class 方法熟练使用 C/C++ 的人，比较容易想到用 class 来存储数据 12345678910111213def Record(): stu_id = None name = None score = None def __init__(self, _id, _name, _score): self.stu_id = _id self.name = _name self.score = _score sheet = []for record in raw_data: sheet.append(Record(**record))# 这种方法需要定义出来一个 class，代码同样显得比较麻烦 namedtuple实际上，这种场景最合适的数据结构就是 namedtuple，namedtuple 可以理解为用最简单的代码去定义一个 Record Class 1234567891011from collections import namedtupleRecord &#x3D; namedtuple(&#39;Record&#39;, [&#39;stu_id&#39;, &#39;name&#39;, &#39;score&#39;])sheet &#x3D; []for record in raw_data: sheet.append(Record._make(record)) for r in sheet: print(r.stu_id, r.name, r.score)# 相比之下，这种方法显得非常 explicit，习惯使用这种数据结构，处理 csv 数据的时候可以大大提高代码可读性。","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Python 中的 import 机制","slug":"Python-20210107-Python-中的-import-机制","date":"2021-01-07T02:56:12.000Z","updated":"2021-01-07T02:58:44.711Z","comments":true,"path":"2021/01/07/Python-20210107-Python-中的-import-机制/","link":"","permalink":"http://example.com/2021/01/07/Python-20210107-Python-%E4%B8%AD%E7%9A%84-import-%E6%9C%BA%E5%88%B6/","excerpt":"module import 12+ A/ - a.py import m from m import * 1- m.py # empty 1234 &#39;&#39;&#39;最简单的 import 情况&#39;&#39;&#39;","text":"module import 12+ A/ - a.py import m from m import * 1- m.py # empty 1234 &#39;&#39;&#39;最简单的 import 情况&#39;&#39;&#39; package import 12+ A/ - a.py import m from m import * import C from C import * 1- m.py import C from C import * 12+ C&#x2F; - __init__.py # empty 1234567 &#39;&#39;&#39;package 的 import Q - ImportError: No module named C A : python2 中，package 文件夹下必须有 __init__.py&#39;&#39;&#39; relative import 123456################################################################################## &#x27;import 关键字的 相对导入&#x27;+ X/ + A/ - __init__.py - a.py import m from m import * import C from C import * 1- m.py import C from C import * 123456789101112131415161718&#39;&#39;&#39;在 A 的 父级目录执行 python -c &quot;import A.a&quot; a.py:1 --&gt; import m Q - ModuleNotFoundError: No module named &#39;m&#39; A : import &lt;pkg&#x2F;module&gt;， pkg&#x2F;module 必须在 PYTHONAPTH 路径下，所以这里有两种解决方案， 一种是将目录 A 的路径加入 PYTHONPATH；一种是改成 import A.m。 很明显后一种改法固定了调用脚本与 packageA 的相对路径关系，因此只有在 A 作为 X 的一个 subpackage 才可以这么写；而 PYTHONPATH 又跟代码所在的路径相关，因此也不太实用。 所以这种情况下就需要用 from &lt;&gt; import &lt;&gt; 语法，这种语法支持 relative import&#39;&#39;&#39;################################################################################### &#39;from ... import ... 的相对导入&#39;+ X&#x2F; + A&#x2F; - __init__.py - a.py # import A.m from m import * # import A.C from C import * 1- m.py # import A.C from C import * 123456789101112131415161718192021 + C&#x2F;&#39;&#39;&#39;修正好 import m&#x2F;C 的错误之后，继续执行 python -c &quot;import A.a&quot; a.py:1 --&gt; import A.m m.py:2 --&gt; from C import * Q - ModuleNotFoundError: No module named &#39;m&#39; A : 这里可以通过改 PYPATHPATH 消除这个错误； 如果不改环境变量的话，from ... import ... 语法支持相对导入，改成 from .C import * # 这里的 .C 是相对于 __package__ 变量的, 这一句等价于下面 from __package__.C # 由于执行的语句是 import A.m， 所以这里的 __package__&#x3D;&#39;A&#39;，所以等价于下面 from A.C import *&#39;&#39;&#39;################################################################################## &#39;from ... import ... 的导入(2)&#39;+ X&#x2F; + A&#x2F; - __init__.py - a.py # import A.m from .m import * # import A.C from .C import * 1- m.py # import A.C from .C import * 1234 + C&#x2F;+ B&#x2F; - __init__.py - b.py from ..A import * 123456789101112131415161718&#39;&#39;&#39;将 A 中的导入全部都变成相对导入之后，试一下在 B 里面导入 package A，执行 python -c &quot;import B.b&quot; --- b.py:1 --&gt; from ..A import * Q - ValueError: attempted relative import beyond top-level package A : 这是由于 b.py 中的 import 语句使用了上一级的 package，而调用语句是 import B.b，只有一层 package， 要避免这个错误，需要将 X 作为一个 package 运行： python -c &quot;import X.B.b&quot;&#39;&#39;&#39;################################################################################### &#39;module 的执行&#39;+ X&#x2F; + A&#x2F; - __init__.py - a.py # import A.m from .m import * # import A.C from .C import * 1- m.py # import A.C from .C import * 1234 + C&#x2F;+ B&#x2F; - __init__.py - b.py from ..A import * 12345678910111213141516&#39;&#39;&#39;先总结一下，当你实现一个模块 a.py 后，如果你想在其他路径下写代码调用这个模块，就会用到形如 import A.a 这样的语句，但是这种情况下，a.py 当中的 import 语句可能会报错。因为 import 语句只支持绝对导入，所以这种情况要用 from .. import ..，并且将其改成相对导入的形式。但是这种情况下，你再回到文件夹 A，却无法执行 python a.py 了 --- a.py:2 --&gt; from .m import * Q - ModuleNotFoundError: No module named &#39;__main__.m&#39;; &#39;__main__&#39; is not a package A : 执行 import A.a 的时候，a 作为一个 module，from 语句从 __package__ 变量相对的路径下去 import 执行 python A&#x2F;a.py 的时候， a 作为一个 脚本，__package__&#x3D;None，from 语句从 __name__ 的相对路径下去 import 这时正确的做法是将 a.py 作为一个 module 执行。 python [-i] -m A.a # 用了这么久才知道 python 有个 -i 选项 !!!!!!!!&#39;&#39;&#39;","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Python tips","slug":"Python-20210107-Python-tips","date":"2021-01-07T02:52:07.000Z","updated":"2021-01-07T02:55:31.630Z","comments":true,"path":"2021/01/07/Python-20210107-Python-tips/","link":"","permalink":"http://example.com/2021/01/07/Python-20210107-Python-tips/","excerpt":"收集一些短小的 Python 代码段","text":"收集一些短小的 Python 代码段 123456# 查看磁盘占用import osvfs = os.statvfs(&#x27;/&#x27;)vfstotal = vfs.f_blocks * statvfs.f_bsizeused = vfs.f_bsize * (vfs.f_blocks - vfs.f_bfree) 123# 输出保留 2 位小数a = 3.1415926print( round(a,2) ) 123456# 查看文件类型improt filetypef = &#x27;1.txt&#x27;kind = filetype.guess(f)print(kind.mime)","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Linux .so 文件编译","slug":"C-20210107-Linux-so-文件编译","date":"2021-01-07T02:46:50.000Z","updated":"2021-01-07T02:50:40.647Z","comments":true,"path":"2021/01/07/C-20210107-Linux-so-文件编译/","link":"","permalink":"http://example.com/2021/01/07/C-20210107-Linux-so-%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91/","excerpt":"http://www.cnblogs.com/tzhangofseu/archive/2011/11/15/2249585.html","text":"http://www.cnblogs.com/tzhangofseu/archive/2011/11/15/2249585.html .so生成 在 soDemo.cpp文件中实现函数1234#include&lt;iostrem&gt;void fun()&#123; std::cout&lt;&lt;&quot;hello&quot;&lt;&lt;std::endl;&#125; 使用 g++ 编译动态链接库1g++ soDemo.cpp -shared -fPIC -o libsoDemo.so .so使用 在 socallDemo.cpp文件中直接调用库函数123456#include&lt;iostream&gt;void fun();int main()&#123; fun(); retrun 0;&#125; 使用 g++ 编译程序，在命令行参数中指定 .so文件123g++ socallDemo.cpp -L. -lsoDemo -o socallDemo# -L. 指定 .so 文件路径为当前目录# -lsoDemo 指定 .so 文件的名称为 libsoDemo.so 运行程序的时候需要让 loader 能够找到 .so文件http://blog.csdn.net/sahusoft/article/details/7388617方法1. 修改 /etc/ld.so.conf 文件，在其中加入 .so文件所在路径方法2. 修改环境变量 LD_LIBRARY_PATHexport LD_LIBRARY_PATH= $path_to_lib:$LD_LIBRARY_PATH","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"动态链接库","slug":"动态链接库","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"}]},{"title":"DLL 编译","slug":"C-20210107-DLL-编译","date":"2021-01-07T02:46:13.000Z","updated":"2021-01-07T02:51:03.554Z","comments":true,"path":"2021/01/07/C-20210107-DLL-编译/","link":"","permalink":"http://example.com/2021/01/07/C-20210107-DLL-%E7%BC%96%E8%AF%91/","excerpt":"http://www.jellythink.com/archives/111http://www.cnblogs.com/fangyukuan/archive/2010/06/20/1761464.html","text":"http://www.jellythink.com/archives/111http://www.cnblogs.com/fangyukuan/archive/2010/06/20/1761464.html dll生成 使用关键字声明导出函数 新建 win32 项目，项目名为 dllDemo 在 dllDemo.cpp 中编写代码 导出函数的代码用关键字 __declspec(dllexport) 声明12345extern &quot;C&quot; __declspec(dllexport) void SayHello()&#123; std::cout&lt;&lt;&quot;This function is exported from .dll&quot;&lt;&lt;std::endl; ::MessageBoxW(NULL, L&quot;Hello&quot;, L&quot;fangyukuan&quot;, MB_OK);&#125; 编译 win32 项目 使用.def文件声明导出函数 新建 win32 项目，项目名为 dllDemo 在 dllDemo.cpp 中编写代码 导出函数不再需要关键字声明12345void SayHello()&#123; std::cout&lt;&lt;&quot;This function is exported from .dll&quot;&lt;&lt;std::endl; ::MessageBoxW(NULL, L&quot;2_DLLDemo::Hello&quot;, L&quot;fangyukuan&quot;, MB_OK);&#125; 新建 .def 文件123LIBRARY &quot;dllDemo&quot;EXPORTS SayHello 编译 win32 项目 dll使用 隐式链接隐式链接在**项目配置**中指定导入函数（即 .dll 文件中的导出函数），代码中只需要声明导入函数就可以调用 建立 win32控制台项目 声明并调用导入函数123456extern &quot;C&quot; __declspec(dllimport) void SayHello(void);int _tmain(int argc, _TCHAR* argv[])&#123; SayHello(); return 0;&#125; 在工程配置中指定 .lib文件的路径方法1. 属性-&gt;链接器-&gt;常规-&gt;附加库目录：指向.lib文件的路径; 属性-&gt;链接器-&gt;输入-&gt;附加依赖项：.lib文件的文件名方法2. 在代码中指定导入库文件.lib1#pragma comment(lib, &quot;dllDemo.lib&quot;) 编译运行 显式链接显式链接在**代码**中加载.dll文件显示链接的时候不需要提供 .lib文件；但是，如果 .dll中存在依赖项，并且依赖项没有被导入，.dll会加载失败 1234567891011121314typedef void (*SayHello)();int _tmain(int argc, _TCHAR* argv[])&#123; HMODULE hDll &#x3D; LoadLibrary(&quot;dllDemo.dll&quot;); if (hDll !&#x3D; NULL) &#123; SayHello sayhello_proc &#x3D; (SayHello)GetProcAddress(hDll, &quot;SayHello&quot;); if (sayhello_proc !&#x3D; NULL) &#123; sayhello_proc(); &#125; FreeLibrary(hDll); &#125; &#125; 查看 dll 导出函数：dumpbin -exports &lt;*.dll&gt;","categories":[{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"动态链接库","slug":"动态链接库","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"}]},{"title":"C3D User Guide","slug":"Caffe-20210107-C3D-User-Guide","date":"2021-01-07T02:42:22.000Z","updated":"2021-01-07T02:43:58.043Z","comments":true,"path":"2021/01/07/Caffe-20210107-C3D-User-Guide/","link":"","permalink":"http://example.com/2021/01/07/Caffe-20210107-C3D-User-Guide/","excerpt":"C3D User GuideDu Tran (Last modified Mar 20, 2017) C3D-v1.1 is released with new models (Mar 01, 2017). ● No documentation for v1.1 yet, but some examples for feature extraction, training, and fine-tuning are provided.","text":"C3D User GuideDu Tran (Last modified Mar 20, 2017) C3D-v1.1 is released with new models (Mar 01, 2017). ● No documentation for v1.1 yet, but some examples for feature extraction, training, and fine-tuning are provided. The below guide was written for C3D-v1.0I. C3D Feature ExtractionIf you have installed C3D successfully (same as install caffe and its dependences), following the following steps: Download pre-trained model and save it to YOUR_C3D_HOME/examples/c3d_feature_extraction Change directory to YOUR_C3D_HOME/examples/c3d_feature_extraction Run: sh c3d_sport1m_feature_extraction_frm.sh or sh c3d_sport1m_feature_extraction_video.sh If you can run the examples successfully, then you should find the extracted features in the output folders. If you run to “out of memory” error, then you should consider to reduce the batch-size (see section I.B) If you can run feature extraction with frames successfully, but fail with the video inputs. The cause may come from video codecs. Make sure you had compiled your OpenCV and Ffmpeg with shared-flags are on. make sure that ‘shuffle: false’ in your data layer when you use C3D as a feature extractor. This help us to keep the correspondences between the input clips and the output features. I.A Extract C3D features for your own videos or framesPrepare your input files C3D allows you to use video inputs as sequences of frames or video files. In the case of video files (.mp4, .avi, .mov), make sure that your machine has codecs, opencv, and ffmpeg installed properly. In the case of using frames, C3D assumes that each video is a folder with frames which are numbered starting from 1 to N (number of frames). The frame names are formatted as “video_folder/%06d.jpg”. Note that: frame numbers starting from 1 (e.g. 1..N) for using frame as inputs, and starting from 0 (e.g. [0..N-1]) for using video as inputs. Prepare your setting files There are two setting files you need to prepare: input-list and output prefix. In the provided example, they are: input_list_frm.txt, input_list_video.txt, and output_list_prefix.txt in YOUR_C3D_HOME/examples/c3d_feature_extraction/prototxt The input list file is a text file where each line contain information for a clip that you are inputting into C3D for extracting features. Each line has the following format: where is only used for training, testing, or fine-tuning, but NOT for extracting features, thus can be ignored (in the provided example, they are filled with 0s). For , we have two cases. For the setting with video file inputs, is the full path and filename of the video (e.g. input/avi/v_ApplyEyeMakeup_g01_c01.avi). For the setting with frame inputs, is the full path to the folder containing frames of the video (e.g. input/frm/v_ApplyEyeMakeup_g01_c01/). Finally, the is used to specify the starting frame of the clip. We note that C3D extract feature of 16-frame-long clips. For example, if starting frame is 1, then you are extracting features for the clip (from the video specified by ) from frame 1 to 16. If starting frame is 17, then the clip of interest is from frame 17 to 32. Note that in the provided examples, we have sampled clips from videos with step size (or stride) of 16 frames. You can use different sampling step-size: e.g. as dense as every 1 frame or sparser e.g. every 32 frames. The output prefix file is used to specify the locations for extracting features to be saved. Each line is formatted as Each line in the prefix file is corresponded to a line in the input list file (in the same order, e.g. line 1 in prefix file is the output prefix for the clip of line 1 in the list file). C3D will save features are output_prefix.[feature_name] (e.g. prefix.fc6). It is recommend that for each video, you should create an output folder and the prefix lines are formatted as sprintf(“output_folder/%06d”, starting_frame). That means each clip has its starting frame as identifier and file extensions are used for different features. Remember to create output folders, as C3D does not create them. Extract C3D features Assume that you have prepared your setting files, then you need to modify the prototxt file to point to the input list file. In the prototxt file, looks for line: source: &quot;prototxt/input_list_frm.txt&quot; Also remember set the use_image: true if you use images as inputs or false if use videos as inputs. Use extract_image_features tool to extract features. The arguments used by this tools is follow: extract_image_features.bin … In which: &lt;feature_extractor_prototxt_file&gt;: is prototxt file (provided in example) which points to your input list file. &lt;c3d_pre_trained_model&gt;: is the C3D pre-trained model that you downloaded. &lt;gpu_id&gt;: GPU ID you would like to run (starting from 0), if this is set to -1, then it will use CPU. &lt;mini_batch_size&gt;: your mini batch size. Default is 50, but you can modify this number, depend on your GPU memory. &lt;number_of_mini_batches&gt;: Number of mini-batches you want to extract features. For examples, if you have 100 clips to extract features and you are using mini-batch size of 50, then this parameter should be set to 2. However, if you have 101 clips to be extracted features, then this number should be set to 3. &lt;output_prefix_file&gt;: Your output prefix file. &lt;feature_name1&gt;: You can list as many feature names as possible as long as they are in the names of the output blobs of the network (see prototxt file for all layers, but they look like fc6-1, fc7-1, fc8-1, pool5, conv5b, prob,...). You can find the following command line provided in the example as below: GLOG_logtosterr=1 ../../build/tools/extract_image_features.bin prototxt/c3d_sport1m_feature_extractor_frm.prototxt conv3d_deepnetA_sport1m_iter_1900000 0 50 1 prototxt/output_list_prefix.txt fc7-1 fc6-1 prob I.B Extract C3D features with smaller or larger batch-size In case you have more or less memory, you can adjust the mini-batch size (larger or smaller than 50). To do that, you need to change this parameter in the prototxt file of the network (find line e.g. batch_size: 50). And you also need to input the newly-adjust parameters of and in the command line. After extracted C3D features, you can use the provided MATLAB script (read_binary_blob.m ) to read the features for further analysis. II. Train 3D ConvNetA. Compute volume mean from listThis tool allows you to compute volume mean for you own dataset which can be useful for both training from scratch or fine-tuning C3D on your own dataset. Usage:GLOG_logtostderr=1 compute_volume_mean_from_list input_chunk_list length height width sampling_rate output_file [dropping rate] Arguments:input_chunk_list: the same as the list file used in feature extractionlength: the length of the clip used in training (e.g. 16)height, width: size of frame e.g. 128, 171sampling_rate: this is used to adjust the frame rate in you clip (e.g. clip length=16, sampling=1, then your clip is a 16-consecutive frame video chunk. Or if clip length=16, while sampling rate=2, then you clip is 32-frame long clips, but you sample 1 of every 2 frames)output_file: the output mean file.dropping_rate: In case you dataset is too large (e.g. 1M), you may want to compute the mean from a subset of your clips. Setting this to n, meaning the dropping rate is 1:n, choose 1 sample among every n clips for computing mean. If you prefer to use mean_value, instead of volume_mean file, then you can set this mean_value field in your data layer. This is equivalent to the volume mean with all values are set to mean_value. B. Train your own network from scratchAssume you have your input_data_list, your train/test prototxt and your solver prototxt, you can use train_net to train the network. C. An example of training from scratch on UCF101 Change directory to YOUR_C3D_HOME/examples/c3d_train_ucf101/ run sh create_volume_mean.sh to compute the volume mean file run sh train_ucf101.sh to train, expect a couple days to finish run sh test_ucf101.sh to test, expect about 15’ to complete and you should have ~45% accuracy (this is clip accuracy) III. Fine-tune C3DAssume you have download the C3D pre-trained model. You can try the fine-tuning example, by: Change directory to YOUR_C3D_HOME/examples/c3d_finetuning Run: sh ucf101_finetuning.sh When fine-tuning is done, you can test your fine-tuned model by running: sh ucf101_testing.sh [Added 05/10/2016] In case you don’t have time to fine-tune C3D on UCF101 yourself, here we provide the C3D model fine-tuned on UCF101: https://www.dropbox.com/s/mkc9q7g4wnqnmcv/c3d_ucf101_finetune_whole_iter_20000 Simply download this model to YOUR_C3D_HOME/examples/c3d_finetuning and run sh ucf101_testing.sh (assume that you have made sure your test_01.lst file points to your UCF101 frames). This will give an accuracy of 80.19% (clip accuracy). NOTE: this model is fine-tuned on UCF101 “train split 1”, thus it is only valid to test on “test split 1”. FAQs● Do we have MATLAB or Python wrappers for extracting C3D features? Unfortunately, we don’t have them yet.● Can I use C3D on a CPU?This version of C3D is built on an old caffe branch, so there is no ‘CPU_ONLY’ mode inMakefile. But you can do that by the following: Compile C3D as normal (it requires CUDA driver to compile, but if you don&#39;t have GPU, you still can run on a CPU). To train using CPU, you can modify solver file to solver_mode: CPU (see here https://github.com/facebook/C3D/blob/master/examples/c3d_train_ucf101/conv3d_ucf101_solver.prototxt#L19) To test using CPU, in the command line use CPU instead of GPU (https://github.com/facebook/C3D/blob/master/examples/c3d_train_ucf101/test_ucf101.sh) and no GPU_ID is needed. To extract features with CPU, use GPU_ID = -1, instead of 0 as in the example here (https://github.com/facebook/C3D/blob/master/examples/c3d_feature_extraction/c3d_sport1m_feature_extraction_frm.sh) ● Email me your questions? (trandu -at- fb.com) or post on github. This is more preferred because I sometime miss some emails. Github keeps tracks much better.","categories":[{"name":"Caffe","slug":"Caffe","permalink":"http://example.com/categories/Caffe/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"Action Recgnition","slug":"Action-Recgnition","permalink":"http://example.com/tags/Action-Recgnition/"},{"name":"Caffe","slug":"Caffe","permalink":"http://example.com/tags/Caffe/"}]},{"title":"查看 caffemodel 内容","slug":"Caffe-20210107-查看-caffemodel-内容","date":"2021-01-07T02:37:29.000Z","updated":"2021-01-07T02:39:26.057Z","comments":true,"path":"2021/01/07/Caffe-20210107-查看-caffemodel-内容/","link":"","permalink":"http://example.com/2021/01/07/Caffe-20210107-%E6%9F%A5%E7%9C%8B-caffemodel-%E5%86%85%E5%AE%B9/","excerpt":"","text":"使用 Python 接口，查看 .caffemodel 文件内容训练好一个网络后，使用 Python 接口进行部署的时候，需要两个文件 trian.prototxt 和 xx.caffemodel。初始化网络的时候，首先会通过 train.prototxt 生成网络的拓扑结构，我们可以在 netscope 预览网络拓扑结构；网络搭建好了之后，Caffe 会从预训练模型中载入参数，对网络参数进行初始化，这个时候有三种情况： prototxt 中出现的层，caffemodel 中有对应的层：这是最常见的情况，网络参数会使用 caffemodel 中存储的参数进行初始化。如果两者的结构参数不一样，就会抛出异常（shape mismatch）。比较典型的有：conv层/pool层 的 kernel-size，channel 不一样；fc层 的输入/输出 维度不一样。 prototxt 中出现的层，caffemodel 中没有对应的层：这种情况下，网络参数会使用 prototxt 中指定的 filler 方法进行初始化，等同于这一层 train from scratch；使用 ImageNet 预训练模型训练其他图片分类模型，修改最后一个 fc层 的名字，就是这种场景。 caffemodel 中出现的层，prototxt 中没有对应的层：这种情况下，caffemodel 中的参数就不会使用，在 Caffe 中会打印出 Ignore layer ** 这样的 log 信息。 举例来说：使用 下面的 pretrain.prototxt 训练出来 caffemodel，然后初始化 train.prototxt 的参数时：layer-A 会被 ignore；layer-B 会使用 pretrain-model 的参数；layer-C 会使用 高斯分布初始化 123456789# pretrain.prototxtlayer&#123; name: layer-A # param in this layer will be ignored when training train.prototxt ...&#125;layer&#123; name: layer-B # param in this layer will be used to initalize training prototxt ...&#125; 123456789101112# train.prototxtlayer&#123; name: layer-B ...&#125;layer&#123; name: layer-C # this layer does not have cordnate layer in pretrained model, will be initialize by weight-filler weiget-filler:&#123; type: guassian std: 0.1 &#125;&#125; 下面言归正传，prototxt 是文本文件，很容易看到 待训练模型 的网络结构，那么，如何看到预训练模型的网络结构呢？直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import caffe.proto.caffe_pb2 as caffe_pb2model_f = &#x27;pretrain.caffemodel&#x27;model = caffe_pb2.NetParameter()with open(model_f, &#x27;rb&#x27;) as f: string = f.read() model.ParseFromString(string) # this instruction will cost much timelayers = model.layerlayers[0]&#x27;&#x27;&#x27;name: &quot;input-data&quot;type: &quot;Python&quot;top: &quot;data&quot;top: &quot;im_info&quot;top: &quot;gt_boxes&quot;phase: TRAINpython_param &#123;module: &quot;roi_data_layer.layer&quot;layer: &quot;RoIDataLayer&quot;param_str: &quot;\\&#x27;num_classes\\&#x27;: 3&quot;&#125;&#x27;&#x27;&#x27;for layer in layers: print(layer.name)&#x27;&#x27;&#x27;input-datadata_input-data_0_splitim_info_input-data_1_splitgt_boxes_input-data_2_splitconv1_1relu1_1conv1_2relu1_2pool1conv2_1relu2_1conv2_2relu2_2pool2conv3_1relu3_1conv3_2relu3_2conv3_3relu3_3pool3conv4_1relu4_1conv4_2relu4_2conv4_3relu4_3pool4conv5_1relu5_1conv5_2relu5_2conv5_3relu5_3conv5_3_relu5_3_0_splitrpn_conv/3x3rpn_relu/3x3rpn/output_rpn_relu/3x3_0_splitrpn_cls_scorerpn_cls_score_rpn_cls_score_0_splitrpn_bbox_predrpn_bbox_pred_rpn_bbox_pred_0_splitrpn_cls_score_reshaperpn_cls_score_reshape_rpn_cls_score_reshape_0_splitrpn-datarpn_loss_clsrpn_loss_bboxrpn_cls_probrpn_cls_prob_reshapeproposalroi-dataroi_pool5fc6relu6drop6fc7relu7drop7fc7_drop7_0_splitcls_score6bbox_pred6loss_clsloss_bbox&#x27;&#x27;&#x27; 使用 Python 接口，修改 caffemodel 的内容在上面的接口中，我们可以看到，读取 caffemodel 的过程实际上是 load 一串二进制方式存储的字符串，相对地，我们也可以将 字符串序列化成为二进制文件，成为一个 caffemodel，实际上，使用 Caffe 训练模型的时候，就是通过这样一个函数保存模型的，当保存路径不存在或没有权限的时候，这个接口还会抛出异常，我们调用这个函数的 Python 接口，就可以修改预训练 caffemodel 中的参数了。","categories":[],"tags":[]},{"title":"使用 Python 接口制作 lmdb","slug":"Caffe-20210107-使用-Python-接口制作-lmdb","date":"2021-01-07T02:33:48.000Z","updated":"2021-01-07T02:36:10.508Z","comments":true,"path":"2021/01/07/Caffe-20210107-使用-Python-接口制作-lmdb/","link":"","permalink":"http://example.com/2021/01/07/Caffe-20210107-%E4%BD%BF%E7%94%A8-Python-%E6%8E%A5%E5%8F%A3%E5%88%B6%E4%BD%9C-lmdb/","excerpt":"使用 lmdb 的 Python 接口制作数据集Caffe 输入格式：一般来说，使用 Caffe 训练的过程，网络结构的第一层是都用来处理输入数据的，输入数据的形式大多数为图片（NLP 工作中，输入的一般是文本的特征，不过这种情况不太常见）。Caffe 的数据输入层有以下几种：","text":"使用 lmdb 的 Python 接口制作数据集Caffe 输入格式：一般来说，使用 Caffe 训练的过程，网络结构的第一层是都用来处理输入数据的，输入数据的形式大多数为图片（NLP 工作中，输入的一般是文本的特征，不过这种情况不太常见）。Caffe 的数据输入层有以下几种： 12345678910111213141516root@p3d-container:/bigdata/dxx/pseudo-3d-residual-networks/caffe/src/caffe/layers# ll *data_layer.cpp-rw-r--r-- 1 root root 4118 Mar 22 09:25 base_data_layer.cpp-rw-r--r-- 1 root root 4313 Mar 22 09:25 data_layer.cpp-rw-r--r-- 1 root root 4826 Mar 22 09:25 dummy_data_layer.cpp-rw-r--r-- 1 root root 6136 Mar 22 09:25 hdf5_data_layer.cpp-rw-r--r-- 1 root root 6946 Mar 22 09:25 image_data_layer.cpp-rw-r--r-- 1 root root 4414 Mar 22 09:25 memory_data_layer.cpp-rw-r--r-- 1 root root 17544 Mar 22 09:25 window_data_layer.cpp################################################################## 其中，base_data_layer.cpp 定义了数据层的基类；## data_layer.cpp 支持 **lmdb/leveldb** 格式的输入## hdf5_data_layer.cpp 支持 **hdf5** 格式的输入## image_data_layer.cpp 支持 **图片** 直接输入## 其他的三个 layer 我不太了解，感兴趣可以查阅相关资料################################################################ 我们平时最常见的情况就是使用 lmdb/leveldb 作为输入，Caffe 的 mnist example 就是使用的这两个格式。因为这样比直接使用 image 进行输入要更快一些（原因可能是因为 lmdb/leveldb 支持 prefetch 操作，可以节省 IO 时间），其中 lmdb 比 leveldb 更快，体积更小。目前 Caffe 最常见的输入就是 lmdb 格式。那么怎么制作 lmdb 呢？ Caffe 提供了一个 convert_imageset 程序，按照指定的格式整理好 image 和 label，直接调用命令可以将图片转换为 lmdb。具体操作参考官网，这里不详细介绍。 lmdb 的 Python 接口简单的情况下，我们可以直接利用官方提供的工具，将图片数据转换为 lmdb，然后利用 data_layer 的 transform_param 对数据进行简单的预处理或者数据增强操作。但是某些特殊情况下，transform_param 可能无法实现我们想要的预处理。这种情况下，我们可以修改 data_layer 的源码，实现想要的功能，当然这样就比较麻烦了，更为简单的方法就是，我们可以在制作 lmdb 之前先实现想要的预处理操作，然后将图片制作成 lmdb，这就是下面要介绍的内容。同理，如果想用这种方法实现比较复杂的数据增强功能也是可以的，不过，这种情况下，lmdb 占用的空间会相应的增加。我这次的任务是让 Caffe 实现视频输入功能，因此需要将 16 个连续视频帧 stack 起来，制作成一个 clip，后续的网络会对 clip 进行卷积操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import lmdbimport numpy as npimport cv2import caffefrom caffe.proto import caffe_pb2#basic setting# 这个设置用来存放lmdb数据的目录lmdb_file &#x3D; &#39;lmdb_data&#39;batch_size &#x3D; 256# create the lmdb file# map_size指的是数据库的最大容量，根据需求设置lmdb_env &#x3D; lmdb.open(lmdb_file, map_size&#x3D;int(1e12))lmdb_txn &#x3D; lmdb_env.begin(write&#x3D;True)# 因为caffe中经常采用datum这种数据结构存储数据datum &#x3D; caffe_pb2.Datum()item_id &#x3D; -1for x in range(1000): item_id +&#x3D; 1 #prepare the data and label #data &#x3D; np.ones((3,64,64), np.uint8) * (item_id%128 + 64) #CxHxW array, uint8 or float # pic_path设置成图像目录, 0表示读入灰度图 data &#x3D; cv2.imread(pic_path, 0) # label 设置图像的label就行 label &#x3D; item_id%128 + 64 # save in datum datum &#x3D; caffe.io.array_to_datum(data, label) keystr &#x3D; &#39;&#123;:0&gt;8d&#125;&#39;.format(item_id) lmdb_txn.put( keystr, datum.SerializeToString() ) # write batch if(item_id + 1) % batch_size &#x3D;&#x3D; 0: lmdb_txn.commit() lmdb_txn &#x3D; lmdb_env.begin(write&#x3D;True) print (item_id + 1)# write last batchif (item_id+1) % batch_size !&#x3D; 0: lmdb_txn.commit() print &#39;last batch&#39; print (item_id + 1)","categories":[{"name":"Caffe","slug":"Caffe","permalink":"http://example.com/categories/Caffe/"}],"tags":[{"name":"Caffe","slug":"Caffe","permalink":"http://example.com/tags/Caffe/"},{"name":"LMDB","slug":"LMDB","permalink":"http://example.com/tags/LMDB/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Py-faster-rcnn","slug":"Caffe-20210107-Py-faster-rcnn","date":"2021-01-07T02:25:06.000Z","updated":"2021-01-07T02:32:12.913Z","comments":true,"path":"2021/01/07/Caffe-20210107-Py-faster-rcnn/","link":"","permalink":"http://example.com/2021/01/07/Caffe-20210107-Py-faster-rcnn/","excerpt":"使用 faster-rcnn 检测游戏中的血条https://github.com/rbgirshick/py-faster-rcnn这一周使用 rbg 大神的 py-faster-rcnn 训练王者荣耀视频中的人物血条，因为之前已经有不少经验，以为可以直接了当得到结果，但是事实却并不那么如意，现在将实验过程简单总结一下。","text":"使用 faster-rcnn 检测游戏中的血条https://github.com/rbgirshick/py-faster-rcnn这一周使用 rbg 大神的 py-faster-rcnn 训练王者荣耀视频中的人物血条，因为之前已经有不少经验，以为可以直接了当得到结果，但是事实却并不那么如意，现在将实验过程简单总结一下。 环境准备 实验环境：实验的环境配置是 Python-2.7, OpenCV-2.4.9, Caffe-1.0, cudnn-v6 安装依赖项：faster-rcnn 使用的是 Caffe 框架，首先需要安装 Caffe 的依赖，另外还需要一些 Python 环境，通过 pip 即可安装。1pip install cpython easydict 编译 faster-rcnn 从 github pull 代码 1git clone --recursive https:&#x2F;&#x2F;github.com&#x2F;rbgirshick&#x2F;py-faster-rcnn.git 更新 Caffehttp://blog.csdn.net/rzjmpb/article/details/52373012github 中的代码使用的 Caffe 版本很古老，因此不支持 cudnnv5，为了使用 cudnn，可以升级 Caffe 或者安装低版本的 cudnn，这里选择升级 Caffe.12345cd py-faster-rcnn&#x2F;caffe-fast-rcnn&#x2F;git remote add caffe https:&#x2F;&#x2F;github.com&#x2F;BVLC&#x2F;caffe.git # git config --list git fetch caffegit merge -X theirs caffe&#x2F;master merge 之后需要注释掉 python_layer.hpp 中的一行代码12$ vi caffe-fast-rcnn/include/caffe/layers/python_layer.hpp +29// self_.attr(&quot;phase&quot;) = static_cast&lt;int&gt;(this-&gt;phase_); // &lt;================ 配置 Makefile.config注意打开 WITH_PYTHON_LAYER=1 编译Caffe 和 faster-rcnn 12345cd py-faster-rcnn&#x2F;caffe-fater-rcnn&#x2F;make -jmake pycaffecd py-faster-rcnn&#x2F;lib&#x2F;make Caffe 默认使用的是 Python2, OpenCV2; faster-rcnn 使用系统环境变量中的 Python 解释器。一定要注意两者保持一致，特别是由于不可抗原因必须使用 Python3 的场景，确保 Caffe 和 faster-rcnn 的编译环境保持一致（faster-rcnn 中有大量的 Python2 接口不被 Python3兼容，使用 Python3 需要做很多修改，或者在 Github 上寻找其他 fork 分支） 数据准备一般按照 pascal_voc 的格式准备数据，需要准备三个文件夹 my_data/VOC2007/Annotations/Annotation 文件夹下面是 XML 文件，具体格式如下：1234567891011121314151617181920212223242526272829303132&lt;annotation&gt; &lt;folder&gt;VOC2007&lt;/folder&gt; &lt;filename&gt;img.jpg&lt;/filename&gt; &lt;size&gt; &lt;width&gt;1280&lt;/width&gt; &lt;height&gt;720&lt;/height&gt; &lt;depth&gt;3&lt;/depth&gt; &lt;/size&gt; &lt;object&gt; &lt;bndbox&gt; &lt;xmin&gt;548&lt;/xmin&gt; &lt;xmax&gt;711&lt;/xmax&gt; &lt;ymin&gt;255&lt;/ymin&gt; &lt;ymax&gt;287&lt;/ymax&gt; &lt;/bndbox&gt; &lt;name&gt;health_blue&lt;/name&gt; &lt;truncated&gt;0&lt;/truncated&gt; &lt;difficult&gt;0&lt;/difficult&gt; &lt;/object&gt; &lt;object&gt; &lt;bndbox&gt; &lt;xmin&gt;675&lt;/xmin&gt; &lt;xmax&gt;842&lt;/xmax&gt; &lt;ymin&gt;373&lt;/ymin&gt; &lt;ymax&gt;407&lt;/ymax&gt; &lt;/bndbox&gt; &lt;name&gt;health_red&lt;/name&gt; &lt;truncated&gt;0&lt;/truncated&gt; &lt;difficult&gt;0&lt;/difficult&gt; &lt;/object&gt; &lt;segmented&gt;0&lt;/segmented&gt;&lt;/annotation&gt; my_data/VOC2007/ImageSets/ImageSets/Main 文件夹下面是 TXT 文件，总共有 4 个，分别是 trainval.txt, train.txt, val.txt, test.txt， 文件中每一行代表一张图片； my_data/VOC2007/JPEGImages/JPEGImages 文件夹下面保存的是图片。 这里有几个小细节：（1）图片的文件名后缀是 .jpg；（2）ImageSets 文件夹下面的 txt 是没有后缀的；（3）xml 中矩形框字段的 tag 是 bndbox，不是常用的 bbox；（4）cls 的名字最好全部使用小写英文字母和下划线，因为 faster-rcnn 会将字符全部转换为小写；（5）注意检查 xml 中是否每一张图片都含有 object 字段，没有 object 字段的 xml 进入网络训练不会报错，但是对训练结果会有影响。 制作完数据集后，在 data/ 目录下，建立软连接，指向 my_data/ 文件夹 12cd py-faster-rcnn&#x2F;data&#x2F;ln -s my_data&#x2F; VOCdevkit2007 更改网络设置faster-rcnn 的网络结构由两部分组成，一部分在 models/ 目录下，这里的主要包含 prototxt， 用来初始化 Solver 和 Network；另一部分在 lib/ 目录下，这里包含 rpn, roi_layer, nms 等模块，以及用来 读取和解析 xml 文件的代码。 models/py-faster-rcnn 提供了两种训练方法，一种是 alt-opt 训练，一种是 end2end 训练，关于两种训练的差别可以参考 Github 上的 readme，另外我们还可以选择使用三种不同的 Backbone Network： {VGG16, VGG-M, ZF}，这里我们选择性能最好的 VGG16，训练方式为 end2end 训练。对应目录为 models/pascal_voc/VGG16/faster_rcnn_end2end/– 修改 train.prototxt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283$ vi models&#x2F;pascal_voc&#x2F;VGG16&#x2F;faster_rcnn_end2end&#x2F;train.prototxt# input_data 层（第 11 行）， 修改 num_classes 为 cls+1layer &#123; name: &#39;input-data&#39; type: &#39;Python&#39; top: &#39;data&#39; top: &#39;im_info&#39; top: &#39;gt_boxes&#39; python_param &#123; module: &#39;roi_data_layer.layer&#39; layer: &#39;RoIDataLayer&#39; # param_str: &quot;&#39;num_classes&#39;: 21&quot; param_str: &quot;&#39;num_classes&#39;: 3&quot; # &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#125;&#125;# roi_data 层（第 530 行）， 修改 num_classes 为 cls+1layer &#123; name: &#39;roi-data&#39; type: &#39;Python&#39; bottom: &#39;rpn_rois&#39; bottom: &#39;gt_boxes&#39; top: &#39;rois&#39; top: &#39;labels&#39; top: &#39;bbox_targets&#39; top: &#39;bbox_inside_weights&#39; top: &#39;bbox_outside_weights&#39; python_param &#123; module: &#39;rpn.proposal_target_layer&#39; layer: &#39;ProposalTargetLayer&#39; # param_str: &quot;&#39;num_classes&#39;: 21&quot; param_str: &quot;&#39;num_classes&#39;: 3&quot; # &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &#125;&#125;# cls_score 层（第 620 行）， 修改 num_output 为 cls+1layer &#123; name: &quot;cls_score&quot; type: &quot;InnerProduct&quot; bottom: &quot;fc7&quot; top: &quot;cls_score&quot; param &#123; lr_mult: 1 &#125; param &#123; lr_mult: 2 &#125; inner_product_param &#123; # num_output: 21 num_output: 3 # &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; weight_filler &#123; type: &quot;gaussian&quot; std: 0.01 &#125; bias_filler &#123; type: &quot;constant&quot; value: 0 &#125; &#125;&#125;# box_pred 层（第 643 行）， 修改 num_output 为 4*(cls+1)layer &#123; name: &quot;bbox_pred&quot; type: &quot;InnerProduct&quot; bottom: &quot;fc7&quot; top: &quot;bbox_pred&quot; param &#123; lr_mult: 1 &#125; param &#123; lr_mult: 2 &#125; inner_product_param &#123; # num_output: 84 num_output: 12 # &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; weight_filler &#123; type: &quot;gaussian&quot; std: 0.001 &#125; bias_filler &#123; type: &quot;constant&quot; value: 0 &#125; &#125;&#125; – 修改 test.prototxt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$ vi models&#x2F;pascal_voc&#x2F;VGG16&#x2F;faster_rcnn_end2end&#x2F;test.prototxt# cls_score 层（第 567 行）， 修改 num_output 为 cls+1layer &#123; name: &quot;cls_score&quot; type: &quot;InnerProduct&quot; bottom: &quot;fc7&quot; top: &quot;cls_score&quot; param &#123; lr_mult: 1 &#125; param &#123; lr_mult: 2 &#125; inner_product_param &#123; # num_output: 21 num_output: 3 # &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; weight_filler &#123; type: &quot;gaussian&quot; std: 0.01 &#125; bias_filler &#123; type: &quot;constant&quot; value: 0 &#125; &#125;&#125;# box_pred 层（第 592 行）， 修改 num_output 为 4*(cls+1)layer &#123; name: &quot;bbox_pred&quot; type: &quot;InnerProduct&quot; bottom: &quot;fc7&quot; top: &quot;bbox_pred&quot; param &#123; lr_mult: 1 &#125; param &#123; lr_mult: 2 &#125; inner_product_param &#123; # num_output: 84 num_output: 12 # &lt;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; weight_filler &#123; type: &quot;gaussian&quot; std: 0.001 &#125; bias_filler &#123; type: &quot;constant&quot; value: 0 &#125; &#125;&#125; – 修改 solver.prototxt 修改 solver 中的参数，使之适合训练自己的数据； faster-rcnn 的另外大多数网络参数在 lib/fast-rcnn/config.py 中，附有详细的注释，可以参考注释进行修改。 lib/ – 修改 pascal_voc.py 由于自己训练数据的类别数与 pascal_voc 不同，因此需要稍微修改一下 12345678910vi lib/datasets/pascal_voc.py# 修改 self._classes 为自己的类别：# self._classes = (&#x27;__background__&#x27;, # always index 0# &#x27;aeroplane&#x27;, &#x27;bicycle&#x27;, &#x27;bird&#x27;, &#x27;boat&#x27;,# &#x27;bottle&#x27;, &#x27;bus&#x27;, &#x27;car&#x27;, &#x27;cat&#x27;, &#x27;chair&#x27;,# &#x27;cow&#x27;, &#x27;diningtable&#x27;, &#x27;dog&#x27;, &#x27;horse&#x27;,# &#x27;motorbike&#x27;, &#x27;person&#x27;, &#x27;pottedplant&#x27;,# &#x27;sheep&#x27;, &#x27;sofa&#x27;, &#x27;train&#x27;, &#x27;tvmonitor&#x27;)self._classes = (&#x27;__background__&#x27;, # always index 0 &#x27;health_blue&#x27;, &#x27;health_red&#x27;) 开始训练 建立测试结果的文件夹： 1mkdir -p data/VOCdevkit2007/results/VOC2007/Main/ 训练完成后，会进行一次测试，如果不手动新建文件夹，测试的时候会报错说找不到这个目录。 直接使用 faster-rcnn 的 脚本进行训练： 1.&#x2F;experiments&#x2F;scripts&#x2F;faster_rcnn_end2end.sh 0 VGG16 pascal_voc 最大迭代次数在 ./experiments/scripts/faster_rcnn_end2end.sh 中进行设置； 训练的 log 存储在 experiments/logs/ 中， 也可以自己重定向出来。 测试模型 faster-rcnn 提供的训练脚本，在使用训练集验证集训练完成后，会在测试集上进行测试，输出模型的 AP 和 AR； 如果想使用单张图片进行测试，并且看到可视化效果，可以参考 tools/demo.py， demo.py 使用 matplotlib 进行可视化，对脚本稍加修改，可以将测试结果保存成图片存储下来。 修改脚本代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#!&#x2F;usr&#x2F;bin&#x2F;env python# --------------------------------------------------------# Faster R-CNN# Copyright (c) 2015 Microsoft# Licensed under The MIT License [see LICENSE for details]# Written by Ross Girshick# --------------------------------------------------------&quot;&quot;&quot;Demo script showing detections in sample images.See README.md for installation instructions before running.&quot;&quot;&quot;import _init_pathsfrom fast_rcnn.config import cfgfrom fast_rcnn.test import im_detectfrom fast_rcnn.nms_wrapper import nmsfrom utils.timer import Timerimport matplotlib.pyplot as pltimport numpy as npimport scipy.io as sioimport caffe, os, sys, cv2import argparseimport globCLASSES&#x3D;(&#39;__background__&#39;,&#39;health_blue&#39;,&#39;health_red&#39;)def vis_detections(im, class_name, dets, thresh&#x3D;0.5): inds &#x3D; np.where(dets[:, -1] &gt;&#x3D; thresh)[0] boxes, scores &#x3D; ([], []) for i in inds: bbox &#x3D; dets[i, :4] score &#x3D; dets[i, -1] boxes.append( dets[i, :4] ) scores.append(score) print(bbox, score) return boxes, scoresdef demo(net, im, filename, out_dir): timer &#x3D; Timer() timer.tic() scores, boxes &#x3D; im_detect(net, im) timer.toc() print(&#39;-----------------------------------------------------&#39;) print ((&#39;Detection &#123;&#125; took &#123;:.3f&#125;s for &#123;:d&#125; object proposals&#39;).format(filename, timer.total_time, boxes.shape[0])) CONF_THRESH &#x3D; 0.8 NMS_THRESH &#x3D; 0.1 for cls_ind, cls in enumerate(CLASSES[1:]): cls_ind +&#x3D; 1 # because we skipped background cls_boxes &#x3D; boxes[:, 4*cls_ind:4*(cls_ind + 1)] cls_scores &#x3D; scores[:, cls_ind] dets &#x3D; np.hstack((cls_boxes, cls_scores[:, np.newaxis])).astype(np.float32) keep &#x3D; nms(dets, NMS_THRESH) dets &#x3D; dets[keep, :] _boxes, _scores &#x3D; vis_detections(im, cls, dets, thresh&#x3D;CONF_THRESH) for box, score in zip( _boxes, _scores): display_str &#x3D; cls + &#39; &#39; + str(score) cv2.rectangle(im, tuple(box[:2]), tuple(box[2:]), (255,0,0), 2) cv2.putText(im, display_str, tuple(box[:2]), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255,255,255), 2) cv2.imwrite( os.path.join( out_dir, filename), im)def parse_args(): &quot;&quot;&quot;Parse input arguments.&quot;&quot;&quot; parser &#x3D; argparse.ArgumentParser(description&#x3D;&#39;Faster R-CNN demo&#39;) parser.add_argument(&#39;model_name&#39;, help&#x3D;&#39;model name&#39;, type&#x3D;str) parser.add_argument(&#39;--gpu&#39;, dest&#x3D;&#39;gpu_id&#39;, help&#x3D;&#39;GPU device id to use [0]&#39;, default&#x3D;1, type&#x3D;int) parser.add_argument(&#39;--cpu&#39;, dest&#x3D;&#39;cpu_mode&#39;, help&#x3D;&#39;Use CPU mode (overrides --gpu)&#39;, action&#x3D;&#39;store_true&#39;) parser.add_argument(&#39;--data_dir&#39;, dest&#x3D;&#39;data_dir&#39;, help&#x3D;&#39;data path&#39;,default&#x3D;&#39;&#x2F;bigdata&#x2F;dxx&#x2F;py-faster-rcnn&#x2F;demo&#x2F;&#39;, type&#x3D;str) parser.add_argument(&#39;--video_name&#39;, dest&#x3D;&#39;video_name&#39;, help&#x3D;&#39;video name&#39;,default&#x3D;&#39;test.mp4&#39;, type&#x3D;str) parser.add_argument(&#39;--image_name&#39;, dest&#x3D;&#39;image_name&#39;, help&#x3D;&#39;image name&#39;,default&#x3D;&#39;test.mp4&#39;, type&#x3D;str) parser.add_argument(&#39;--model_dir&#39;, dest&#x3D;&#39;model_dir&#39;, help&#x3D;&#39;model path&#39;,default&#x3D;&#39;&#x2F;bigdata&#x2F;dxx&#x2F;py-faster-rcnn&#x2F;models&#x2F;&#39;, type&#x3D;str) args &#x3D; parser.parse_args() return argsif __name__ &#x3D;&#x3D; &#39;__main__&#39;: cfg.TEST.HAS_RPN &#x3D; True # Use RPN for proposals args &#x3D; parse_args() out_dir &#x3D; os.path.join(args.data_dir, args.model_name) if not os.path.exists(out_dir): os.mkdir(out_dir) os.system(&#39;&#123;&#125; &#123;&#125; &#123;&#125;&#39;.format(&#39;chmod&#39;, &#39;777&#39;, out_dir)) print(&#39;output images to &#123;&#125;&#39;.format(out_dir)) prototxt &#x3D; &#39;models&#x2F;pascal_voc&#x2F;VGG16&#x2F;faster_rcnn_end2end&#x2F;test.prototxt&#39; caffemodel &#x3D; os.path.join(args.model_dir, args.model_name, &#39;vgg16_faster_rcnn_final.caffemodel&#39;) if args.cpu_mode: caffe.set_mode_cpu() else: caffe.set_mode_gpu() caffe.set_device(args.gpu_id) cfg.GPU_ID &#x3D; args.gpu_id net &#x3D; caffe.Net(prototxt, caffemodel, caffe.TEST) print (&#39;\\n\\nLoaded network &#123;:s&#125;&#39;.format(caffemodel)) image_f &#x3D; os.path.join(args.data_dir, &#39;image&#39;, args.image_name, &#39;*.jpg&#39;) for im_f in sorted(glob.glob(image_f)): im &#x3D; cv2.imread(im_f) demo(net, im, os.path.basename(im_f), out_dir) &#39;&#39;&#39; video_f &#x3D; os.path.join(args.data_dir, &#39;video&#39;, args.video_name) video_cap &#x3D; cv2.VideoCapture(video_f) frame_cnt &#x3D; int(video_cap.get(cv2.CAP_PROP_FRAME_COUNT)) error_frame &#x3D; max(20, frame_cnt &#x2F; 50) for i, frame_index in enumerate(range(0, frame_cnt, 10)): video_cap.set(cv2.CAP_PROP_POS_FRAMES, frame_index) status, frame &#x3D; video_cap.read() if not status: error_frame -&#x3D; 1 if error_frame &gt; 0: continue video_cap.release() raise Exception(&#39;Bad video file&#39;) demo(net, frame, frame_index+&#39;.jpg&#39;, out_dir) &#39;&#39;&#39; 测试图片的路径格式如下： 1234567891011121314+ /bigdata/dxx/py-faster-rcnn/ + models/ + &lt;model_name&gt;/ - vgg16_faster_rcnn_final.caffemodel + demo/ + video/ - test.mp4 + image/ + test.mp4/ - 001.jpg - 002.jpg + &lt;model_name&gt;/ # detection results - 001.jpg - 002.jpg python tools/demo.py &lt;model_name&gt; 这次使用了迭代 5000 次的模型进行测试，在两个视频上进行了简单的测试，在测试的 100 张图片上，完全没有出现 漏检或错检，准确率达到 1.0 错误列表 注意事项： 1. 编译过程中，每次更新环境，最好重新编译 Caffe、pycaffe、faster-rcnn/lib2. 运行过程中，每次重新开始训练/测试，最好删除掉 data/cache/ 和 data/VOCdevkit2007/annotationcache/ AttributeError: can&#39;t set attribute 这是由于 git merge 之后没有修改 caffe-fast-rcnn/include/caffe/layers/python_layer.hpp 导致的。 AttributeError: &#39;module&#39; object has no attribute &#39;text_format&#39; 这个和 protobuf 的版本有关 12$ vi lib&#x2F;fast-rcnn&#x2F;train.py+ import google.protobuf.text_format TypeError: slice indices must be integers or None or have an __index__ method 123456789101112131415# $ vi lib/rpn/proposal_target_layer.pydef _get_bbox_regression_labels(bbox_target_data, num_classes): clss = bbox_target_data[:, 0] bbox_targets = np.zeros((clss.size, 4 * num_classes), dtype=np.float32) bbox_inside_weights = np.zeros(bbox_targets.shape, dtype=np.float32) inds = np.where(clss &gt; 0)[0] for ind in inds: ind = int(ind) &lt;================= cls = clss[ind] start = int(4 * cls) &lt;================= end = int(start + 4) &lt;================= bbox_targets[ind, start:end] = bbox_target_data[ind, 1:] bbox_inside_weights[ind, start:end] = cfg.TRAIN.BBOX_INSIDE_WEIGHTS return bbox_targets, bbox_inside_weights TypeError: &#39;numpy.float64&#39; object cannot be interpreted as an index https://github.com/rbgirshick/py-faster-rcnn/issues/481 numpy1.12 版本以后，不再支持 1.0，2.0 这样的浮点数作为索引，因此需要安装低版本的numpy 1pip install -U numpy&#x3D;&#x3D;1.11.0 另外还可以找到所有出问题的地方，使用 astype() 函数进行类型转换 1234567891011$ vi lib/roi_data_layer/minibatch.py +26fg_rois_per_image = np.round(cfg.TRAIN.FG_FRACTION *rois_per_image).astype(np.int)$ vi lib/datasets/ds_utils.py +12hashes = np.round(boxes * scale).dot(v).astype(np.int)$ vi lib/fast_rcnn/test.py line +129hashes = np.round(blobs[&#x27;rois&#x27;] * cfg.DEDUP_BOXES).dot(v).astype(np.int)$ vi lib/rpn/proposal_target_layer.py +60fg_rois_per_image = np.round(cfg.TRAIN.FG_FRACTION * rois_per_image).astype(np.int)","categories":[{"name":"Caffe","slug":"Caffe","permalink":"http://example.com/categories/Caffe/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"Caffe","slug":"Caffe","permalink":"http://example.com/tags/Caffe/"},{"name":"Object Detection","slug":"Object-Detection","permalink":"http://example.com/tags/Object-Detection/"},{"name":"Faster RCNN","slug":"Faster-RCNN","permalink":"http://example.com/tags/Faster-RCNN/"}]},{"title":"openpose_train","slug":"Caffe-20210107-openpose-train","date":"2021-01-07T02:22:03.000Z","updated":"2021-01-07T02:23:33.837Z","comments":true,"path":"2021/01/07/Caffe-20210107-openpose-train/","link":"","permalink":"http://example.com/2021/01/07/Caffe-20210107-openpose-train/","excerpt":"https://github.com/CMU-Perceptual-Computing-Lab/openposehttps://github.com/CMU-Perceptual-Computing-Lab/openpose_train","text":"https://github.com/CMU-Perceptual-Computing-Lab/openposehttps://github.com/CMU-Perceptual-Computing-Lab/openpose_train 1. 拉取代码1git clone https:&#x2F;&#x2F;github.com&#x2F;CMU-Perceptual-Computing-Lab&#x2F;openpose_train.git 2. 下载数据集2.1. cocoapi12345678910mkdir -p openpose_train&#x2F;dataset&#x2F;mkdir -p openpose_train&#x2F;dataset&#x2F;COCO&#x2F;cd openpose_train&#x2F;dataset&#x2F;COCO&#x2F;git clone --recurse https:&#x2F;&#x2F;github.com&#x2F;gineshidalgo99&#x2F;cocoapi.git# 安装 mingw, matlab PCT# 编译 gasonMex, maskApiMexcd cocoapi&#x2F;MatlabAPI&#x2F;mex(&#39;CXXFLAGS&#x3D;$CXXFLAGS -std&#x3D;c++11 -Wall&#39;,&#39;-largeArrayDims&#39;,&#39;private&#x2F;gasonMex.cpp&#39;,&#39;..&#x2F;common&#x2F;gason.cpp&#39;,&#39;-I..&#x2F;common&#x2F;&#39;,&#39;-outdir&#39;,&#39;private&#39;);mex(&#39;COMPFLAGS&#x3D;\\$CFLAGS -Wall -std&#x3D;c++11&#39;,&#39;-largeArrayDims&#39;,&#39;private&#x2F;maskApiMex.c&#39;,&#39;..&#x2F;common&#x2F;maskApi.c&#39;,&#39;-I..&#x2F;common&#x2F;&#39;,&#39;-outdir&#39;,&#39;private&#39;); 2.2. coco数据集12345678910# annotations_trainval2017, image_info_test2017 --&gt; dataset&#x2F;cocoapi&#x2F;annotations&#x2F;# train2017, val2017, test2017 --&gt; dataset&#x2F;cocoapi&#x2F;images&#x2F;http:&#x2F;&#x2F;images.cocodataset.org&#x2F;zips&#x2F;train2017.ziphttp:&#x2F;&#x2F;images.cocodataset.org&#x2F;zips&#x2F;val2017.ziphttp:&#x2F;&#x2F;images.cocodataset.org&#x2F;zips&#x2F;test2017.ziphttp:&#x2F;&#x2F;images.cocodataset.org&#x2F;annotations&#x2F;annotations_trainval2017.ziphttp:&#x2F;&#x2F;images.cocodataset.org&#x2F;annotations&#x2F;image_info_test2017.ziphttp:&#x2F;&#x2F;images.cocodataset.org&#x2F;annotations&#x2F;stuff_annotations_trainval2017.zip 2.3. 生成LMDB1234567# 生成 body keypoints LMDB# 依次执行 a1_coco_jsonToNegativesJson, a2_coco_jsonToMat, a3_coco_matToMasks, a4_coco_matToRefinedJsonpython c_generateLmdbs.py# 生成 foot keypoints LMDB# 依次执行 a2_coco_jsonToMat, a4_coco_matToRefinedJsonpython c_generateLmdbs.py 3. 模型训练3.1. 拉取 OpenPose Caffe 和 预训练模型1234567cd &#x2F;openpose_train&#x2F;git clone --recurse github.com&#x2F;CMU-Perceptual-Computing-Lab&#x2F;openpose_caffe_train.gitcd &#x2F;openpose_train&#x2F;dataset&#x2F;mkdir vggwget -c http:&#x2F;&#x2F;www.robots.ox.ac.uk&#x2F;~vgg&#x2F;software&#x2F;very_deep&#x2F;caffe&#x2F;VGG_ILSVRC_19_layers.caffemodelwget -c https:&#x2F;&#x2F;gist.githubusercontent.com&#x2F;ksimonyan&#x2F;3785162f95cd2d5fee77&#x2F;raw&#x2F;bb2b4fe0a9bb0669211cf3d0bc949dfdda173e9e&#x2F;VGG_ILSVRC_19_layers_deploy.prototxt 3.2. 生成 prototxt12cd &#x2F;openpose_train&#x2F;trainingpython d_setLayers.py 3.3. 训练12cd &#x2F;openpose_train&#x2F;training_result&#x2F;pose&#x2F;.&#x2F;train_pose.sh 0 4.测试4.1. 速度测试12345# Test using LMDB:&#x2F;openpose_train&#x2F;openpose_caffe_train&#x2F;build&#x2F;tools&#x2F;caffe time -gpu 0 -model pose_training.prototxt# Test using input layer: 368*368&#x2F;openpose_train&#x2F;openpose_caffe_train&#x2F;build&#x2F;tools&#x2F;caffe time -gpu 0 -model pose_deploy.prototxt -phase TEST | batchsize | 1 | 8 |16 | **deploy**| |--- |--- |--- |--- |--- | |time(ms) |19 |103 |199 |17.3 | 4.2. Evaluate1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768cd &#x2F;openpose.&#x2F;scripts&#x2F;tests&#x2F;pose_accuracy_coco_val.sh # https:&#x2F;&#x2F;github.com&#x2F;gineshidalgo99&#x2F;cocoapi&#x2F;blob&#x2F;master&#x2F;PythonAPI&#x2F;pycocoEvalDemo.ipynb --&gt; evaluate.pypython scripts&#x2F;tests&#x2F;evaluate.pyBody25 baseline: 5000samples&#x2F;119s &#x3D; 42FPS Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.523 Average Precision (AP) @[ IoU&#x3D;0.50 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.763 Average Precision (AP) @[ IoU&#x3D;0.75 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.568 Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D;medium | maxDets&#x3D; 20 ] &#x3D; 0.466 Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D; large | maxDets&#x3D; 20 ] &#x3D; 0.604 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.576 Average Recall (AR) @[ IoU&#x3D;0.50 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.790 Average Recall (AR) @[ IoU&#x3D;0.75 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.613 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D;medium | maxDets&#x3D; 20 ] &#x3D; 0.483 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D; large | maxDets&#x3D; 20 ] &#x3D; 0.709COCO baseline: Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.490 Average Precision (AP) @[ IoU&#x3D;0.50 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.742 Average Precision (AP) @[ IoU&#x3D;0.75 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.520 Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D;medium | maxDets&#x3D; 20 ] &#x3D; 0.426 Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D; large | maxDets&#x3D; 20 ] &#x3D; 0.588 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.544 Average Recall (AR) @[ IoU&#x3D;0.50 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.766 Average Recall (AR) @[ IoU&#x3D;0.75 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.571 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D;medium | maxDets&#x3D; 20 ] &#x3D; 0.442 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D; large | maxDets&#x3D; 20 ] &#x3D; 0.688body23: 5000samples&#x2F;120s &#x3D; 41FPS Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.433 Average Precision (AP) @[ IoU&#x3D;0.50 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.692 Average Precision (AP) @[ IoU&#x3D;0.75 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.450 Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D;medium | maxDets&#x3D; 20 ] &#x3D; 0.360 Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D; large | maxDets&#x3D; 20 ] &#x3D; 0.535 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.484 Average Recall (AR) @[ IoU&#x3D;0.50 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.719 Average Recall (AR) @[ IoU&#x3D;0.75 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.502 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D;medium | maxDets&#x3D; 20 ] &#x3D; 0.378 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D; large | maxDets&#x3D; 20 ] &#x3D; 0.632 90 degree Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.324 Average Precision (AP) @[ IoU&#x3D;0.50 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.602 Average Precision (AP) @[ IoU&#x3D;0.75 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.304 Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D;medium | maxDets&#x3D; 20 ] &#x3D; 0.259 Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D; large | maxDets&#x3D; 20 ] &#x3D; 0.416 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.376 Average Recall (AR) @[ IoU&#x3D;0.50 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.633 Average Recall (AR) @[ IoU&#x3D;0.75 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.366 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D;medium | maxDets&#x3D; 20 ] &#x3D; 0.283 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D; large | maxDets&#x3D; 20 ] &#x3D; 0.505 60 degree Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.345 Average Precision (AP) @[ IoU&#x3D;0.50 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.630 Average Precision (AP) @[ IoU&#x3D;0.75 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.327 Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D;medium | maxDets&#x3D; 20 ] &#x3D; 0.290 Average Precision (AP) @[ IoU&#x3D;0.50:0.95 | area&#x3D; large | maxDets&#x3D; 20 ] &#x3D; 0.425 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.399 Average Recall (AR) @[ IoU&#x3D;0.50 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.662 Average Recall (AR) @[ IoU&#x3D;0.75 | area&#x3D; all | maxDets&#x3D; 20 ] &#x3D; 0.392 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D;medium | maxDets&#x3D; 20 ] &#x3D; 0.313 Average Recall (AR) @[ IoU&#x3D;0.50:0.95 | area&#x3D; large | maxDets&#x3D; 20 ] &#x3D; 0.520","categories":[{"name":"Caffe","slug":"Caffe","permalink":"http://example.com/categories/Caffe/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"Pose Estimation","slug":"Pose-Estimation","permalink":"http://example.com/tags/Pose-Estimation/"},{"name":"Caffe","slug":"Caffe","permalink":"http://example.com/tags/Caffe/"},{"name":"OpenPose","slug":"OpenPose","permalink":"http://example.com/tags/OpenPose/"}]},{"title":"tensorflow object-detecct-api","slug":"TensorFlow-20210107-tensorflow-object-detecct-api","date":"2021-01-07T02:19:14.000Z","updated":"2021-01-07T02:20:47.771Z","comments":true,"path":"2021/01/07/TensorFlow-20210107-tensorflow-object-detecct-api/","link":"","permalink":"http://example.com/2021/01/07/TensorFlow-20210107-tensorflow-object-detecct-api/","excerpt":"0. 安装1234567891011apt-get install protobuf-compilerpip install pillowpip install lxmlpip install jupyterpip install matplotlib# From tensorflow&#x2F;models&#x2F;research&#x2F;protoc object_detection&#x2F;protos&#x2F;*.proto --python_out&#x3D;.# From tensorflow&#x2F;models&#x2F;research&#x2F;export PYTHONPATH&#x3D;$PYTHONPATH:&#96;pwd&#96;:&#96;pwd&#96;&#x2F;slim","text":"0. 安装1234567891011apt-get install protobuf-compilerpip install pillowpip install lxmlpip install jupyterpip install matplotlib# From tensorflow&#x2F;models&#x2F;research&#x2F;protoc object_detection&#x2F;protos&#x2F;*.proto --python_out&#x3D;.# From tensorflow&#x2F;models&#x2F;research&#x2F;export PYTHONPATH&#x3D;$PYTHONPATH:&#96;pwd&#96;:&#96;pwd&#96;&#x2F;slim 1. 训练命令https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/running_locally.md 12345# From the tensorflow/models/research/ directorypython object_detection/train.py \\ --logtostderr \\ --pipeline_config_path=$&#123;PATH_TO_YOUR_PIPELINE_CONFIG&#125; \\ --train_dir=$&#123;PATH_TO_TRAIN_DIR&#125; [pipeline_config.pbtxt]123456789101112131415161718192021222324&#96;&#96;&#96;PATH_TO_TRAIN_DIR&#96;&#96;&#96;：训练模型保存位置---## 2. PIPELINE_CONFIG&lt;https:&#x2F;&#x2F;github.com&#x2F;tensorflow&#x2F;models&#x2F;blob&#x2F;master&#x2F;research&#x2F;object_detection&#x2F;g3doc&#x2F;configuring_jobs.md&gt;&#96;&#96;&#96;protomodel &#123;(... Add model config here...)&#125;train_config : &#123;(... Add train_config here...)&#125;train_input_reader: &#123;(... Add train_input configuration here...)&#125;eval_config: &#123;&#125;eval_input_reader: &#123;(... Add eval_input configuration here...)&#125; pipeline_config 文件分为以下五个部分 model: object_detection/samples/model_configs train_config: 12345678910111213141516171819202122232425262728293031batch_size: 1optimizer &#123;momentum_optimizer: &#123;learning_rate: &#123; manual_step_learning_rate &#123; initial_learning_rate: 0.0002 schedule &#123; step: 0 learning_rate: .0002 &#125; schedule &#123; step: 900000 learning_rate: .00002 &#125; schedule &#123; step: 1200000 learning_rate: .000002 &#125; &#125;&#125;momentum_optimizer_value: 0.9&#125;use_moving_average: false&#125;fine_tune_checkpoint: &quot;&#x2F;usr&#x2F;home&#x2F;username&#x2F;tmp&#x2F;model.ckpt-#####&quot;from_detection_checkpoint: truegradient_clipping_by_norm: 10.0data_augmentation_options &#123; random_horizontal_flip &#123; &#125;&#125; train_input_reader:12345tf_record_input_reader &#123;input_path&#123; &quot;&#x2F;usr&#x2F;home&#x2F;username&#x2F;data&#x2F;train.record&quot;&#125;label_map_path: &quot;&#x2F;usr&#x2F;home&#x2F;username&#x2F;data&#x2F;label_map.pbtxt&quot; 3. TF-recordhttps://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/preparing_inputs.md 1234567891011# From tensorflow&#x2F;models&#x2F;research&#x2F;wget http:&#x2F;&#x2F;host.robots.ox.ac.uk&#x2F;pascal&#x2F;VOC&#x2F;voc2012&#x2F;VOCtrainval_11-May-2012.tartar -xvf VOCtrainval_11-May-2012.tarpython object_detection&#x2F;create_pascal_tf_record.py \\ --label_map_path&#x3D;object_detection&#x2F;data&#x2F;pascal_label_map.pbtxt \\ --data_dir&#x3D;VOCdevkit --year&#x3D;VOC2012 --set&#x3D;train \\ --output_path&#x3D;pascal_train.recordpython object_detection&#x2F;create_pascal_tf_record.py \\ --label_map_path&#x3D;object_detection&#x2F;data&#x2F;pascal_label_map.pbtxt \\ --data_dir&#x3D;VOCdevkit --year&#x3D;VOC2012 --set&#x3D;val \\ --output_path&#x3D;pascal_val.record 4. export trained modelhttps://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/exporting_models.md 123456# From tensorflow&#x2F;models&#x2F;research&#x2F;python object_detection&#x2F;export_inference_graph.py \\ --input_type image_tensor \\ --pipeline_config_path object_detection&#x2F;dxx_models&#x2F;inception_resnet_v2&#x2F;pipeline_config.pbtxt \\ #$&#123;PIPELINE_CONFIG_PATH&#125; i --trained_checkpoint_prefix object_detection&#x2F;dxx_models&#x2F;inception_resnet_v2&#x2F;train&#x2F;model.ckpt-381545 \\ #$&#123;MODEL_PATH&#125; --output_directory object_detection&#x2F;dxx_models&#x2F;inception_resnet_v2&#x2F;train&#x2F;output_inference_graph.pb2","categories":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://example.com/categories/TensorFlow/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://example.com/tags/TensorFlow/"},{"name":"Object Detection","slug":"Object-Detection","permalink":"http://example.com/tags/Object-Detection/"}]},{"title":"Non-local Neural Network","slug":"Caffe2-20210107-Non-local-Neural-Network","date":"2021-01-07T01:47:01.000Z","updated":"2021-01-07T01:56:32.100Z","comments":true,"path":"2021/01/07/Caffe2-20210107-Non-local-Neural-Network/","link":"","permalink":"http://example.com/2021/01/07/Caffe2-20210107-Non-local-Neural-Network/","excerpt":"Facebook 的 Non-local 开源了，上周简单试验了一下怎么用。记录一下步骤https://github.com/facebookresearch/video-nonlocal-net","text":"Facebook 的 Non-local 开源了，上周简单试验了一下怎么用。记录一下步骤https://github.com/facebookresearch/video-nonlocal-net Caffe2 Installhttps://github.com/facebookresearch/video-nonlocal-net/blob/master/INSTALL.md 依赖库12345678910111213141516171819202122232425git clone --recrusive http://github.com/caffe2/caffe2.gitapt-get updateapt-get install -y --no-install-recommends \\ build-essential \\ cmake \\ git \\ libgoogle-glog-dev \\ libgtest-dev \\ libiomp-dev \\ libleveldb-dev \\ liblmdb-dev \\ libopencv-dev \\ libopenmpi-dev \\ libsnappy-dev \\ libprotobuf-dev \\ openmpi-bin \\ openmpi-doc \\ protobuf-compiler \\ python-dev \\ python-pip pip install \\ future \\ numpy \\ protobuf 中间可能需要安装 setuptools123456apt install wgetwget http://pypi.python.org/packages/source/s/setuptools/setuptools-0.6c11.tar.gztar -xvf setuptools-0.6c11.tar.gzcd setuptools-0.6c11python setup.py buildpython setup.py install Clone Non-local 代码1234cd caffe2git clone --recursive https://github.com/facebookresearch/video-nonlocal-net.gitrm -rf caffe2/video/cp -r video-nonlocal-net/caffe2_customized_ops/video/ caffe2/video/ Make 123# use_ffmpeg ONmake -jpython caffe2_setup.py install # (not sure how it works) 配置环境变量1export PYTHONPATH=&lt;caffe2-dir&gt;/video-nonlocal-net/lib:$PYTHONPATH Data Preparationhttps://github.com/facebookresearch/video-nonlocal-net/blob/master/DATASET.md 我是用 UCF-101 数据集进行 finetune 的，主要参照了官方的链接制作 LMDB 图片准备首先下载解压 UCF-101 数据集到 /data 目录下12root@dxx# ls /data/UCF-101/ ucfTrainTestlist/ 生成 list 文件官方文档里面使用 gen_py_list.py 生成 trainlist.txt这里我们直接用 ucf101 提供的 trainlist01.txt我们还需要做另外两个工作 （1）ucf101 的标签是从 1 开始，需要改成 0； （2）ucf101 中的 testlist01.txt 里面没有标签信息，需要自己加上12345678910111213141516171819202122232425262728293031323334cd &lt;caffe2-dir&gt;/video-nonlocal-net/process_data/cp -r kinetics/ ucf101/cd ucf101/rm -f *.txtcp /data/ucfTrainTestlist/classInd.txt .cp /data/ucfTrainTestlist/trainlist01.txt .cp /data/ucfTrainTestlist/testlist01.txt .python gen_py_list_football.py&#x27;&#x27;&#x27;&gt;&gt;&gt;pythond = &#123;&#125;for line in open(&#x27;classInd.txt&#x27;): ind, label = line.strip().split() d[label] = ind with open(&#x27;trainlist.txt&#x27;, &#x27;w&#x27;) as f: for line in open(&#x27;trainlist01.txt&#x27;): img, ind = line.strip().split() if ind == &#x27;101&#x27;: ind = &#x27;0&#x27; f.write(&#x27;/data/UCF-101/&#x27; + img + &#x27; &#x27; + ind + &#x27;\\n&#x27;)with open(&#x27;vallist.txt&#x27;, &#x27;w&#x27;) as f: for line in open(&#x27;testlist01.txt&#x27;): img = line.strip() label = img.split(&#x27;/&#x27;)[0] ind = d[label] if ind == &#x27;101&#x27;: ind = &#x27;0&#x27; f.write(&#x27;/data/UCF-101/&#x27; + img + &#x27; &#x27; + ind + &#x27;\\n&#x27;)&#x27;&#x27;&#x27; resize 数据集为了加快训练时候的 IO 速度，我们可以提前把数据集 resize 好，官方直接写好了一个脚本12345678910# 修改 downscale_video_joblib.py:21,22YOUR_DATASET_FOLDER/train/ --&gt; /data/UCF-101/YOUR_DATASET_FOLDER/train_256/ --&gt; /data/UCF-101_s256/ # 注意不能少了路径最后的 &#x27;/&#x27;pip install joblib pandasmkdir -p /data/UCF-101_s256/python downscale_video_joblib.py# 修改 downscale_video_joblib.py:20trainlist.txt --&gt; vallist.txtpython downscale_video_joblib.py 生成 LMDB12345678sed -i &#x27;s/UCF-101/UCF-101_s256/g&#x27; trainlist.txtsed -i &#x27;s/UCF-101/UCF-101_s256/g&#x27; vallist.txtpython shuffle_list_rep.py trainlist_shuffle_rep.txtpip install lmdbbash run_createdb.shbash run_createdb_test.shbash run_createdb_test_multicrop.sh Trainhttps://github.com/facebookresearch/video-nonlocal-net/blob/master/README.md 训练过程可以有很多种设置，这里我选择的是 run_i3d_nlnet_400k.sh 这个脚本，具体区别看官方说明。 123456789101112131415161718192021cd &lt;caffe2-dir&gt;&#x2F;video-nonlocal-net&#x2F;scripts&#x2F;pip install networkxapt install python-yaml# 设置一下 yaml 文件: ..&#x2F;configs&#x2F;DBG_kinetics_resnet_8gpu_c2d_nonlocal_400k.yaml# GPU_NUMS# MODEL.NUM_CLASSES# TRAIN.BATCH_SIZE# TEST.BATCH_SIZE# TEST.DATASET_SIZE# 修改 solver 超参数# 修改 run_i3d_nlnet_400k.sh# 6: TRAIN.PARAMS_FILE ..&#x2F;data&#x2F;pretrained_model&#x2F;i3d_nonlocal_8x8_IN_pretrain_400k_clean.pkl \\# 14: FILENAME_GT ..&#x2F;process_data&#x2F;ucf101&#x2F;vallist.txt \\##chmod 777 run_i3d_nlnet_400k.sh.&#x2F;run_i3d_nlnet_400k.sh 按照上面的步骤基本可以开始训练 ucf101了，这里的预训练模型有两种选择，一种是在 Kinetics 上训练时选择的 ImageNet 预训练模型，脚本里面名字是 ../data/pretrained_model/r50_pretrain_c2_model_iter450450_clean.pkl; 一种是在 Kinetics 上训练好的模型 i3d_nonlocal_8x8_IN_pretrain_400k。我选择的是后者，但是刚开始训练的时候就会认为已经进行到了 400k 次迭代，所以直接结束了训练。我最后在 ../tools/train_net_video.py:131 加上 start_model_iter = 0训练了起来（小伙伴可以尝试其他更好的解决办法）。一旦网络保存过一次 checkpoint，下次训练就会从 checkpoint 里选择最新的模型继续训练，这个时候就可以删掉 start_model_iter = 0 了。 Test视频分类这一块的模型测试，通常都会有两层意思，一个是对测试视频进行上述的数据准备操作，对于 C3D (caffe版) 来说，是生成 lst 文件；对于 Non-local I3D (caffe2版) 来说，是生成 lmdb 文件，这两个文件的作用都是定义测试 clip 在 video/image-squence 中对应的帧号，网络读取数据准备的结果文件后，会组织数据送入后面的卷积层。（当然，数据准备过程只与输入层的实现相关，与网络结构没有关系），这一部分工作与训练几乎没有区别，并且可以方便进行测试，因此很容易跑通。另一个意思就是对视频输入进行分类测试，也就是落地部署，一般的开源项目只为了让人复现实验结果，并不会实现这一部分。视频输入 与 文本/lmdb 输入具有不小的 gap，为了能够直接在视频上测试，需要对网络的输入模块进行改动，下面是 caffe2 版 Non-local I3D 部署的步骤。 Input layer modificationhttps://github.com/clover978/video-nonlocal-net/blob/master/tools/deploy_net_video_local.py Image propocesscaffe2_customized_ops/video/customized_video_input_op.h:200-221 summarize 了 Non-local I3D 的 video_input_op 对视频帧进行的预处理过程。更改后的网络结构需要实现对应的功能。1234567891011121314151617181920212223242526272829303132333435# customized_video_input_op.h:206, scaledef _scale(frame, size=(320, 256)): return cv2.resize(frame, size)# customized_video_input_op.h:208,210, cropdef _crop(frame, crop_size=224, type=&#x27;random&#x27;): # type: &#123;&#x27;random&#x27;, &#x27;center&#x27;&#125; h, w = frame.shape[:2] if type == &#x27;random&#x27;: x = random.randint(crop_size//2, w-crop_size//2-1) y = random.randint(crop_size//2, h-crop_size//2-1) elif type == &#x27;center&#x27;: x = w//2 y = h//2 else: logger.warning(&#x27;unknow type, use center crop instead&#x27;) x = w//2 y = h//2 return frame[y-crop_size//2:y+crop_size//2, x-crop_size//2:x+crop_size//2, :]# customized_video_input_op.h:211,212, sampling# @sa: deploy_net_video_local:collect_clip()# customized_video_input_op.h:213, normalizedef _normalize(clip, mean=128, std=1): # just do it over clip return (clip-mean)/std # customized_video_input_op.h:219, channel_swapdef _channel_swap(frame, use_bgr=True): if use_bgr: return cv2.cvtColor(frame, cv2.COLOR_BGR2RGB) else: return frame Q&amp;A 训练过程中，会周期性地进行 test，我在 test 的时候报错 1234Traceback: File &quot;lib&#x2F;utils&#x2F;misc.py:200&quot;: used_gpu_memory &#x3D; out_dict[&#39;Used GPU Memory&#39;]KeyError: Used GPU Memory 查了半天不知道正确的 key 是什么，直接注释掉了 lib/utils/metrics.py:343 1# json_stats[&#39;used_gpu_memory&#39;] &#x3D; misc.get_gpu_stats() 关于训练时使用 i3d_nonlocal_8x8_IN_pretrain_400k 会直接结束训练的问题，作者提供了一个新的脚本，重置了 lr, iteration, momentum 等信息。 1234cd &lt;caffe2-dir&gt;&#x2F;video-nonlocal-net&#x2F;process_data&#x2F;convert_models&#x2F;# 修改 modify_blob_rm.py: 5,6 行input_model_file --&gt; ..&#x2F;..&#x2F;data&#x2F;pretrained_model&#x2F;i3d_nonlocal_8x8_IN_pretrain_400k.pkloutput_model_file --&gt; ..&#x2F;..&#x2F;data&#x2F;pretrianed_model&#x2F;i3d_nonlocal_8x8_IN_pretrain_400k_clean.pkl finetune 的时候，log 中显示的进度是根据 Kinetic 数据集的规模计算，有很大的出入，具体的设置在 &lt;caffe2-dir&gt;/video-nonlocal-net/lib/core/config.py:78, 配置 yaml 文件可以修改，添加 TRAIN.DATASET_SIZE = 9537 训练是输入的是视频，具体按照怎样的规则得到 clip ？github issue 中有两个是与这个问题相关的，可以参考 #12 #15简单来说，第一步会 decode 出输入视频的所有帧，此时如果遇到太短的视频会抛弃掉，从源代码看，最小是 32K 字节。==&gt; video/customized_video_decoder.cc:79第二步从解码出来的帧中，随机选择 clip_length 长度的图片进行训练。 ==&gt; video/customized_video_io.cc:674,687 训练和测试的时候视频经过怎样的预处理？#16#10","categories":[{"name":"Caffe2","slug":"Caffe2","permalink":"http://example.com/categories/Caffe2/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"Action Recgnition","slug":"Action-Recgnition","permalink":"http://example.com/tags/Action-Recgnition/"},{"name":"Caffe2","slug":"Caffe2","permalink":"http://example.com/tags/Caffe2/"}]},{"title":"TSN-Pytorch","slug":"Pytorch-20210107-TSN-Pytorch","date":"2021-01-07T01:23:06.000Z","updated":"2021-01-07T01:25:18.694Z","comments":true,"path":"2021/01/07/Pytorch-20210107-TSN-Pytorch/","link":"","permalink":"http://example.com/2021/01/07/Pytorch-20210107-TSN-Pytorch/","excerpt":"https://github.com/yjxiong/tsn-pytorch 0. IntroTSN 是动作识别领域里面一个很老工作，也是一个很重要的工作。作者开源了代码，是用 Caffe 实现的，但是由于 Pytorch 在学界的流行，作者又重新实现了一个 Pytorch 版本的。代码写的很优雅，基本是可以直接用的，这个简单记录一下使用步骤。TSN 的训练模式有 3 种, (1) RGB, (2) Flow, (3) RGB+Flow, 这里只介绍第一种下文需要用到的代码片段都已经上传到 fork 的 repo 中 https://github.com/clover978/tsn-pytorch","text":"https://github.com/yjxiong/tsn-pytorch 0. IntroTSN 是动作识别领域里面一个很老工作，也是一个很重要的工作。作者开源了代码，是用 Caffe 实现的，但是由于 Pytorch 在学界的流行，作者又重新实现了一个 Pytorch 版本的。代码写的很优雅，基本是可以直接用的，这个简单记录一下使用步骤。TSN 的训练模式有 3 种, (1) RGB, (2) Flow, (3) RGB+Flow, 这里只介绍第一种下文需要用到的代码片段都已经上传到 fork 的 repo 中 https://github.com/clover978/tsn-pytorch 1. Data-Prepare 抽帧：首先生成视频文件列表： 12cd &#x2F;home&#x2F;dxx&#x2F;UCF101&#x2F;UCF101&#x2F;find . -type f &gt; trainvallist.txt 然后抽帧：12cd &lt;tsn-path&gt;python tools&#x2F;extract_frames.py 生成 lst 文件：tsn-pytorch 用文本文件的形式作为输入，读取数据集。文本文件的格式如下：12# 视频帧路径 视频总帧数 视频标签&lt;image_dir_path&gt; &lt;frames_cnt&gt; &lt;label_index&gt; 准备 classInd.txt 文件，用下面的脚本生成训练需要的文本文件：1python gen_tsn_list.py 2. Train ucf101 训练：UCF101数据集 可以直接使用如下的命令训练： 123456789# tools&#x2F;train_tsn.shCUDA_VISIBLE_DEVICES&#x3D;0,1,2,3 \\ python -u main.py ucf101 RGB train_tsn.txt val_tsn.txt \\ --arch BNInception \\ --num_segments 5 --gd 20 \\ --lr 0.001 --lr_steps 70 130 --epochs 180 \\ -b 140 -j 8 --dropout 0.5 --snapshot_pref models&#x2F;meitu_bninception \\ |&amp; tee log.txt 自定义数据集训练：自定义的数据集，可以使用同样的命令训练，训练之前只需要修改 main.py, 将 num_class 替换为自己数据集的类别数123# main.py:25if args.dataset &#x3D;&#x3D; &#39;ucf101&#39;: num_class &#x3D; &lt;datasets classes number&gt; 使用 resume 参数从中间开始训练1--resume models&#x2F;tsn-pytorch&#x2F;meitu_bninception_rgb_1_checkpoint.pth.tar","categories":[{"name":"Pytorch","slug":"Pytorch","permalink":"http://example.com/categories/Pytorch/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"Pytorch","slug":"Pytorch","permalink":"http://example.com/tags/Pytorch/"},{"name":"Action Recgnition","slug":"Action-Recgnition","permalink":"http://example.com/tags/Action-Recgnition/"}]},{"title":"Deep-high-resolution-net.pytorch","slug":"Pytorch-20210107-Deep-high-resolution-net-pytorch","date":"2021-01-07T01:15:54.000Z","updated":"2021-01-07T01:19:30.929Z","comments":true,"path":"2021/01/07/Pytorch-20210107-Deep-high-resolution-net-pytorch/","link":"","permalink":"http://example.com/2021/01/07/Pytorch-20210107-Deep-high-resolution-net-pytorch/","excerpt":"https://github.com/leoxiaobin/deep-high-resolution-net.pytorch","text":"https://github.com/leoxiaobin/deep-high-resolution-net.pytorch 1. 配置 HRNET 环境12345678910111213141516171819202122232425262728293031323334353637383940414243FROM nvidia&#x2F;cuda:11.1-cudnn8-devel-ubuntu18.04LABEL auther&#x3D;clover978# Basic toolchainRUN apt-get update &amp;&amp; apt-get install -y --no-install-recommends \\ build-essential \\ git \\ ffmpeg \\ python3-pip \\ python3-dev \\ libsm6 \\ libxext6 \\ &amp;&amp; cd &#x2F;usr&#x2F;bin \\ &amp;&amp; ln -s &#x2F;usr&#x2F;bin&#x2F;python3 python \\ &amp;&amp; pip3 install --upgrade pip \\ &amp;&amp; apt-get autoremove -y \\ &amp;&amp; rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;* # clone deep-high-resolution-netARG POSE_ROOT&#x3D;&#x2F;workspace&#x2F;deep-high-resolution-netRUN git clone https:&#x2F;&#x2F;gitee.com&#x2F;clover978&#x2F;deep-high-resolution-net.pytorch.git $POSE_ROOTWORKDIR $POSE_ROOTRUN pip3 install --no-cache-dir -r requirements.txt &amp;&amp; \\ pip3 install --no-cache-dir pycocotools numpy opencv-python tqdm tensorboard tensorboardX pyyaml webcolors \\ pip3 install --no-cache-dir torch&#x3D;&#x3D;1.7.0+cu110 torchvision&#x3D;&#x3D;0.8.1+cu110 -f https:&#x2F;&#x2F;download.pytorch.org&#x2F;whl&#x2F;torch_stable.html # build deep-high-resolution-net libWORKDIR $POSE_ROOT&#x2F;libRUN make# install COCO APIARG COCOAPI&#x3D;&#x2F;cocoapiRUN git clone https:&#x2F;&#x2F;gitee.com&#x2F;clover978&#x2F;cocoapi $COCOAPIWORKDIR $COCOAPI&#x2F;PythonAPIRUN make install# clone ARG DET_ROOT&#x3D;&#x2F;workspace&#x2F;Yet-Another-EfficientDet-PytorchRUN git clone https:&#x2F;&#x2F;gitee.com&#x2F;clover978&#x2F;Yet-Another-EfficientDet-Pytorch $DET_ROOTWORKDIR $POSE_ROOT clover fork 的 HRNET(https://gitee.com/clover978/deep-high-resolution-net.pytorch.git) 进行了一些改动： 支持 QDTM 数据集，数据集包含 18 个关键点，不同于 COCO 的 17 个点； 添加代码保存中间模型，每 10 个 epoch 保存一次； 添加 inference 代码，可以对图片文件夹进行遍历，并将结果生成视频。 clover fork 的 cocoapi(https://gitee.com/clover978/cocoapi) 进行了一个改动： 更改 PythonAPI/pycocotools/cocoeval.py:523，以适应 QDTM 数据集的 18 个关键点。 2. 训练、测试12345docker run -itd --name hrnet --ipc host -v &#x2F;home&#x2F;dxx:&#x2F;home&#x2F;dxx -v &#x2F;data:&#x2F;data --net host dxx&#x2F;hrnet:v1$ deep-high-resolution-net.pytorchpython tools&#x2F;train.py --cfg experiments&#x2F;qdtm&#x2F;hrnet&#x2F;w48_384x288_adam_lr1e-3_vault_v3.yaml python tools&#x2F;inference.py --cfg experiments&#x2F;qdtm&#x2F;hrnet&#x2F;w48_384x288_adam_lr1e-3_vault_v3.yaml TEST.MODEL_FILE output&#x2F;output&#x2F;qdtm&#x2F;pose_hrnet&#x2F;w48_384x288_adam_lr1e-3_vault_v3&#x2F;model_best.pth","categories":[{"name":"Pytorch","slug":"Pytorch","permalink":"http://example.com/categories/Pytorch/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"Pytorch","slug":"Pytorch","permalink":"http://example.com/tags/Pytorch/"},{"name":"Pose Estimation","slug":"Pose-Estimation","permalink":"http://example.com/tags/Pose-Estimation/"}]},{"title":"Git commitzen","slug":"others-20210106-Git-commitzen","date":"2021-01-06T12:36:23.000Z","updated":"2021-01-06T12:38:36.300Z","comments":true,"path":"2021/01/06/others-20210106-Git-commitzen/","link":"","permalink":"http://example.com/2021/01/06/others-20210106-Git-commitzen/","excerpt":"Git0. IntroGit 是一种非常常见的 分布式版本管理工具，学习使用 git应该算是程序员的一项基本功了，毕竟稍微有一些体量的公司，都会有自己的版本管理系统。Git 的子命令相当之多，比较复杂的那些，有相关需求的时候上网查就可以了，这篇笔记只记录最简单常用的命令。","text":"Git0. IntroGit 是一种非常常见的 分布式版本管理工具，学习使用 git应该算是程序员的一项基本功了，毕竟稍微有一些体量的公司，都会有自己的版本管理系统。Git 的子命令相当之多，比较复杂的那些，有相关需求的时候上网查就可以了，这篇笔记只记录最简单常用的命令。 1. Why Git以下内容纯属个人理解，没有参考网上资料，不一定正确Git 中引入了几个重要的概念： 分支：一个代码仓库（repo）至少拥有一个 master 分支，还可以拥有多个其他分支，在分支上的开发各自分开，然后合并（merge）到主分支中。 暂存区：在 git 中，磁盘上的代码可以叫做本地代码，被加入到 git仓库的代码处于工作区，工作区的代码的改动不会直接进入分支，而是被放在暂存区中。使用 git diff 命令，可以轻松查看开发迭代在上版本代码上的所有改动。在实际使用过程中会对这些概念有更清晰的认识。 origin/master：git 的代码管理是分布式的，同样一份代码，可以存储在各个不同的地方。这需要依赖一个 git 服务器和一个 origin 分支。因此 git仓库 中的代码总共存在于 5 个地方：本地磁盘、工作区、暂存区、本地分支、云端分支。前四个在本地存储，最后一个在服务器存储，没有 git 服务器同样可以使用 git 做版本管理，只是不支持分布式，本地删掉之后代码就没有了。其中 origin 就是远程仓库的名字，master 是远程分支的名字，当仓库只有一个分支的时候，origin/master 即代表了远端仓库的代码。 2. Git in action使用 git，首先需要配置一下开发者用户名 123git config --global user.name &quot;yourname&quot;git config --global user.email &quot;your.email@gmail.com&quot;git config --list 下面用几个命令，简单介绍 git 的最常见用法 123456789101112131415161718192021222324252627282930313233343536# 创建一个 git 仓库git init # 一般这个命令会在空文件夹下执行，此时工作区为空# 创建一个新文件touch readme.txt # 此时磁盘代码发生了变动，工作区依然为空# 查看分支状态, 将代码加入 git 仓库 ## --&gt; 如果文件是 new file，使用 git add &lt;file&gt; 将其加入仓库，这样文件同时进入了工作区和暂存区 git status git add readme.txt ## --&gt; 如果文件是 modified，代表文件本来处于工作区，但是进行了改动，使用 git add &lt;file&gt; 将其加入暂存区，或者使用 git checkout -- &lt;file&gt; 撤销工作区改动。git diff &lt;file&gt; 可以查看文件的改动 echo &quot;new changes&quot; &gt; readme.txt # 现在工作区和暂存区中的文件是一致的。对文件进行改动 git status git diff git add readme.txt | git checkout -- readme.txt# 提交改动# 使用 git commit 将 暂存区 的修改提交到 git 分支上，每一次 commit 对应 git 分支上的 一个节点。git commit -m &quot;&lt;massage&gt;&quot;orgit commit # edit commit massage in vim# 查看 loggit log# 提交到远端仓库 ## --&gt; 如果本地是一个新仓库，则需要配置远端仓库地址，如果本地仓库是从远端 clone/pull 下来的，则不需要配置 git remote add origin &lt;url&gt; # url 示例 https://github.com/clover978/tsn-pytorchgit push origin master # 将本地分支 push 到远端的 master 分支 （origin 代表远端仓库的地址）# 从远程仓库拉取。代码提交到远端之后，就可以在别的地方拉取代码了 ## --&gt; 如果没有从远端拉取过代码，则使用 git clone 克隆一个新的代码仓库 git clone &lt;url&gt; or git remote add origin &lt;url&gt; # 配置远端仓库地址，然后拉取git pull origin master # 拉取远端的 master 分支到本地 Git commitzen0.. Intro用工具思路规范化 git commit massageGit commitzen 是一个 规范 commit massage 的工具。掌握了 git 之后，自然也就知道 commit massage 是什么东西了。commit massage 需不需要规范化属于个人喜好问题，这篇笔记推荐一种目前流行的 commit massage 规范以及配置方法。 1.. Angular Git Commit Guidelines1234567891011&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;&lt;footer&gt;type: 本次 commit 的类型，诸如 bugfix docs style 等scope: 本次 commit 波及的范围subject: 简明扼要的阐述下本次 commit 的主旨，在原文中特意强调了几点 1. 使用祈使句 2. 首字母不要大写 3. 结尾无需添加标点body: 同样使用祈使句，在主体内容中我们需要把本次 commit 详细的描述一下，比如此次变更的动机，如需换行，则使用 |footer: 描述下与之关联的 issue 或 break change 2. commitizen看完上面规范之后会不会感觉很麻烦，每次都要回忆该怎么写 commit massage。commitzen 就是一个帮助规范化 commit massage 的工具。可以在 github 上欣赏一下该项目的 commits，或者 clone 到本地用 git log 看一下。下面介绍怎么使用 commitzen 命令行安装安装 commitzen-cli 需要先安装 npm 1234# windows下载安装 node.js. https://nodejs.org/en/# linuxapt install npm 安装 commitzen-cli 及 conventional change log 123npm install -g commitizennpm install -g cz-conventional-changelogecho &#39;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&#39; &gt; ~&#x2F;.czrc 使用 git cz 代替 git commit 提交代码 VSCode（推荐如果使用 vscode 的话，可以直接安装 Visual Studio Code Commitizen Support 插件","categories":[{"name":"others","slug":"others","permalink":"http://example.com/categories/others/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"}]},{"title":"Tesseract-OCR","slug":"others-20210106-Tesseract-OCR","date":"2021-01-06T12:34:38.000Z","updated":"2021-01-06T12:38:45.152Z","comments":true,"path":"2021/01/06/others-20210106-Tesseract-OCR/","link":"","permalink":"http://example.com/2021/01/06/others-20210106-Tesseract-OCR/","excerpt":"Tesseract 是 Github 上一个 OCR 的开源项目，目前最新版已经更新到 v4.0.x，最近小小尝试了一下怎么使用这个开源库，记一下笔记。","text":"Tesseract 是 Github 上一个 OCR 的开源项目，目前最新版已经更新到 v4.0.x，最近小小尝试了一下怎么使用这个开源库，记一下笔记。 Install环境： Ubuntu16.04Tesseract 可以使用 apt 安装，但是在 Ubuntu18.04 之前的版本，官方库里面的最新版本只有 3.x.x，作为 Ubuntu16.04 用户，需要先添加 PPA，其他系统版本的 PPA 可以在这里找到。 123apt-get install python-software-properties software-properties-commonadd-apt-repository ppa:alex-p&#x2F;tesseract-ocrapt-get update 添加完 PPA 之后就可以直接 apt 安装了 1apt-get install tesseract-ocr libtesseract-dev 除了 apt 安装外，也可以直接从 github clone代码，然后编译安装， 不再详述。 Language supportTesseract 的模型文件放在 $TESSDATA_PREFIX 指定的位置，当找不到这个环境变量是，默认路径是 /usr/share/tesseract-ocr/4.00/tessdata Teseeract 支持的语言及对应的模型文件可以在 这里 找到 Tesseract 的中文支持有两种方式： 直接 apt 安装apt install tesseract-ocr-chi-sim tesseract-ocr-chi-sim-vert 简体中文语言包模型 12wget https:&#x2F;&#x2F;github.com&#x2F;tesseract-ocr&#x2F;tessdata&#x2F;raw&#x2F;4.00&#x2F;chi_sim.traineddatamv chi_sim.traineddata &#x2F;usr&#x2F;share&#x2F;tesseract-ocr&#x2F;4.00&#x2F;tessdata&#x2F; tesseract --list-langs 查看目前支持的语言 Command Line Usagehttps://github.com/tesseract-ocr/tesseract/wiki/Command-Line-Usage Tesseract 的命令行使用可以参考上面的链接这里列举一个最简答的用法 1234567tesseract input.png output -l eng --oem 3 --psm 3# input.png： 输入的图片# output： 输出文件名（指定 stdout 输出到标准输出）# -l：指定语言，eng（英语，默认），chi_sim（简体中文）# --oem[0,1,2,3]： OCR Engine Mode，4.x.x 版本默认为 3, 就是使用 available 的模型，即 LSTM 模型# --psm[0-13]： Page Segement Mode，默认为 3，自动分页# Tesseract 还有许多许多其他的参数可以设置，具体可以参照上方的链接 Python APIhttps://github.com/sirfz/tesserocrTesseract 官方给出了一个使用 Python API 的 脚本，脚本的原理是使用 ctypes + .so/.dll文件，用 Python 调用 C 的接口，这种方法还需要写 platform specified 的代码，所以比较麻烦。我在网上找到有人写了一个 Python Wrapper， 在 官方 repo 下还可以找到更多 Wrapper 的链接，下面介绍利用这个方法使用 Python 接口。 安装 123apt-get install tesseract-ocr libtesseract-dev libleptonica-dev# 前两个在装 Tesseract 的时候已经安装过了，一定记得要装第三个东西CPPFLAGS&#x3D;-I&#x2F;usr&#x2F;local&#x2F;include pip3 install tesserocr Usage官方 repo 里面给出了很多 接口示例，这里摘抄一个最基本的用法，tesserocr 支持输入 PIL Image 对象或者 图片文件。1234567891011from tesserocr import PyTessBaseAPIimages &#x3D; [&#39;sample.jpg&#39;, &#39;sample2.jpg&#39;, &#39;sample3.jpg&#39;]with PyTessBaseAPI() as api: for img in images: api.SetImageFile(img) print api.GetUTF8Text() print api.AllWordConfidences()# api is automatically finalized when used in a with-statement (context manager).# otherwise api.End() should be explicitly called when it&#39;s no longer needed. ERROR按照上面的步骤，确实可以安装成功 tesserocr， 然后执行 python3 -c &#39;import tesserocr; print(tesserocr.tesseract_version())&#39;，发现版本号竟然是 3.4.0. 于是开始了漫长的升级之旅 卸载 Tesseract3.4.0， tesserocr首先将已经安装的版本卸载掉 重新安装 tesserocr安装之后又出错了， import 的时候找不着 tesseract.so.3。这个就很烦了，无奈之下我只能从源码开始安装 Tesseract， 再从 源码安装 tesserocr， 最后终于成功了。 从源码安装 Tesseracthttps://github.com/tesseract-ocr/tesseract/wiki/Compiling 从源码安装 tesserocr 123git clone https:&#x2F;&#x2F;github.com&#x2F;sirfz&#x2F;tesserocrexport LD_LIBRARY_PATH&#x3D;$LD_LIBRARY_PATH:&#x2F;usr&#x2F;lib&#x2F;:&#x2F;usr&#x2F;local&#x2F;lib&#x2F;pip3 install . 最后问题是终于解决了，具体这两个东西到底哪个是必须要源码编译，哪个可以用 apt/pip 安装，我也不知道，反正两个全部都编译安装的话是可以成功的。注意安装 tesserocr 的时候，确保电脑上只有最新版的 Tesseract","categories":[{"name":"others","slug":"others","permalink":"http://example.com/categories/others/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"OCR","slug":"OCR","permalink":"http://example.com/tags/OCR/"}]},{"title":"Useful bash/powershell commands","slug":"Linux-20210106-Useful-bash-powershell-commands","date":"2021-01-06T12:02:46.000Z","updated":"2021-01-06T12:27:30.783Z","comments":true,"path":"2021/01/06/Linux-20210106-Useful-bash-powershell-commands/","link":"","permalink":"http://example.com/2021/01/06/Linux-20210106-Useful-bash-powershell-commands/","excerpt":"收集一些常用的 Windows Powershell 和 Linux bash 命令","text":"收集一些常用的 Windows Powershell 和 Linux bash 命令 1. Powershell12# 创建软连接New-Item -Path images -ItemType SymbolicLink -Value E:\\coco\\images\\ 12345678910# windows 命令行配置: 设置codepage为 936，GUI的设置经常不能生效Windows Registry Editor Version 5.00[HKEY_CURRENT_USER\\Console\\%SystemRoot%_system32_cmd.exe]&quot;CodePage&quot;=dword:0000fde9&quot;FontFamily&quot;=dword:00000036&quot;FontWeight&quot;=dword:00000190&quot;FaceName&quot;=&quot;Consolas&quot;&quot;ScreenBufferSize&quot;=dword:232900d2&quot;WindowSize&quot;=dword:002b00d2 2. Bash123# 同时在 命令行 和 文件中输出&lt;cmd&gt; | tee &lt;log-file&gt;# echo &quot;hello&quot; 2&gt;&amp;1 | tee output.txt 12# 查看终端大小stty size 12# 查看程序占用swapawk &#x27;/^Swap:/ &#123;SWAP+=$2&#125;END&#123;print SWAP&quot; KB&quot;&#125;&#x27; /proc/$(pid)/smaps 12# 重启 kdekquitapp5 plasmashell &amp;&amp; kstart plasmashell 123456789# 设置系统语言apt install localeslocale-gen zh_CN.utf8locale-gen zh_CNexport LANG=zh_CN.utf8export LC_ALL=zh_CN.utf8export LANGUAGE=zh_CN.utf8update-locale LANG=zh_CN.utf8 LC_ALL=zh_CN.utf8 LANGUAGE=zh_CN.utf8locale -a 1234# sed 命令操作文本sed [-i] &#x27;s/^/HEAD/g&#x27; test.filesed [-i] &#x27;s/$/TAIL/g&#x27; test.filesed &#x27;10,20i new_line_between_10_and_20&#x27; test.file 1234# vncstart: vncserver -geometry 1920x1080 exec: ip:&lt;port&gt;stop: vncserver -kill :&lt;port&gt; 12# 批量重命名文件rename .jpeg .jpg ./* 1234# nohup 后台运行程序nohup ./run.sh &gt; log.txt &amp;# 其中 &amp; 表示将命令放到后台执行; nohup 表示让进程忽略 HUP 信号。这样，关闭当前窗口后，程序仍然会执行，如果想停止程序，只能通过 ps 找到进程号，然后 kill 掉 1234567891011121314151617181920# `screen` 命令提供了一种更强大的后台执行命令方法# 新建一个 会话窗口（Session）screen -S &lt;会话名称&gt;# 列出所有会话screen -ls# 进入一个会话screen -r &lt;会话名称&gt;# 进入会话窗口后，就可以执行需要执行的命令了，在执行过程中退出会话不会中断程序# 在会话窗口中退出会话Ctrl + a + d# 在会话窗口外退出会话screen -d &lt;会话名称&gt;# 可以看到 `screen` 将任务放到后台后，支持随时随地查看任务状态，或者与任务进行交互。不需要像 `nohup` 那样必须重定向出 log 文件（当然实际情况下重定向更为方便）。 123456789101112131415161718192021# 将已经执行的前台任务放到后台# 执行命令./run.sh# 将任务放到后台，此时任务状态是 StoppedCtrl + z# 使用 `jobs` 可以查看任务jobs# 将任务放到后台执行bg &lt;job-id&gt;# 将任务放到前台执行fg &lt;job-id&gt;# 任务放到后台之后，一旦关闭当前窗口，这个窗口下的所有任务都会收到 HUP 信号，从而中断运行，因此还需要另外一个命令。 # 使用 disown 命令，让任务不再附属于当前窗口，这样，使用 jobs 命令会发现任务不见了，关闭当前窗口也不会中断任务。disown -h &lt;job-id&gt;disown -ah # 将所有任务移出作业列表 3. 图像处理1234567# resize 视频，保持较短边大于 256 ffmpeg -i input.mp4 -vf scale=256:256:force_original_aspect_ratio=increase output.mp4# 这条命令计算出来的 w/h 可能是奇数，对于 libx264 编码，无法生成视频ffmpeg -i input.mp4 -vf scale=if(lt(iw\\,ih)\\,256\\,-2):if(lt(iw\\,ih)\\,-2\\,256) output.mp4# 这个命令可以完美实现功能，并且只需要读取一次视频 123# 提取视频帧， 设置 strideffmpeg -i input.mp4 -vf &quot;scale=256:256:force_original_aspect_ratio-increase, select=not(mod(n\\,4))&quot; -vsync vfr images/img-%06d.jpg 12# ffmpeg 抽帧ffmpeg -i test.mp4 -r 1 -ss 0:0:0 -t 0:0:3 -s 1280x720 -f image2 %4d.jpg 12# ffmpeg 剪切视频ffmpeg -ss 00:00:15 -t 00:00:05 -i input.mp4 -vcodec copy -acodec copy output.mp4 123# imagemagick 处理图片convert in.jpg -rotate 90 out.jpgconvert in.jpg -resize 640x360 out.jpg 4. pip 镜像源12# 临时用法： pip install example.whl -i https://pypi.douban.com/simple --trusted-host=pypi.douban.com 12345# 永久配置：# vi ~/.pip/pip.conf [global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Packages Collections","slug":"Linux-20210106-Packages-Collections","date":"2021-01-06T11:59:23.000Z","updated":"2021-01-07T02:41:24.253Z","comments":true,"path":"2021/01/06/Linux-20210106-Packages-Collections/","link":"","permalink":"http://example.com/2021/01/06/Linux-20210106-Packages-Collections/","excerpt":"收集一些比较冷门的 lib, packages 安装命令","text":"收集一些比较冷门的 lib, packages 安装命令 Ubuntu:1234libgthread-2.0.so.0 apt install libglib2.0-0libSM.so.6 apt install libsm6libXrender.so.1 apt install libxrender1libXext.so.6 apt install libxext6 Python312pycocotools pip install &quot;git+https:&#x2F;&#x2F;github.com&#x2F;philferriere&#x2F;cocoapi.git#egg&#x3D;pycocotools&amp;subdirectory&#x3D;PythonAPI&quot;skbuild pip install scikit-build Caffe123456789101112131415161718apt install -y \\ protobuf-compiler \\ libprotobuf-dev \\ libboost-all-dev \\ libgflags-dev \\ libgoogle-glog-dev \\ libatlas-base-dev \\ libopencv-dev \\ libhdf5-dev \\ libleveldb-dev \\ liblmdb-dev \\ libsnappy-dev \\ python-numpy \\ python-setuptools \\ python-opencv \\ ipython \\pip install scikit-image protobuf","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Ubuntu installation","slug":"Paper-Notes-20210106-Ubuntu-installation","date":"2021-01-06T11:51:30.000Z","updated":"2021-01-06T12:27:14.088Z","comments":true,"path":"2021/01/06/Paper-Notes-20210106-Ubuntu-installation/","link":"","permalink":"http://example.com/2021/01/06/Paper-Notes-20210106-Ubuntu-installation/","excerpt":"0. 备份数据 bashrc 文件 docker123docker save -o images.tar $image_id1 $ image_id2docker export -o container_1.tar container_id1docker export -o container_2.tar container_id2 记录重要文件路径","text":"0. 备份数据 bashrc 文件 docker123docker save -o images.tar $image_id1 $ image_id2docker export -o container_1.tar container_id1docker export -o container_2.tar container_id2 记录重要文件路径 1. 制作系统盘 下载 镜像文件 下载安装 大白菜 制作启动盘 2. 安装系统 按照安装流程安装系统 安装 net-tools, openssh123sudo apt update &amp;&amp; sudo apt install -y net-tools, openssh-serverservice ssh startifconfig 关闭图形显示，确认ip地址1234# 关闭图形化显示sudo systemctl set-default multi-user.targetsudo rebootifconfig 3. 挂载硬盘 格式化硬盘，推荐 ext4 创建挂载点 挂载硬盘123sudo mkfs.ext4 /dev/sda1sudo mkdir /datasudo mount /dev/sda1 /data 4. 更新国内源123456789101112131415sudo mv /etc/apt/sources.list /etc/apt/sourses.list.backupsudo vi /etc/apt/sources.listdeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversesudo apt update 5. 安装显卡驱动12345下载显卡驱动https:&#x2F;&#x2F;www.nvidia.cn&#x2F;Download&#x2F;index.aspxsudo apt install gcc makesudo .&#x2F;NVIDIA-Linux-x86_64-455.23.04.run –no-opengl-files -no-x-check -no-nouveau-check 6. 安装 docker123456789101112131415161718192021222324252627# 安装 docker-cecurl -fsSL https:&#x2F;&#x2F;get.docker.com | bash -s docker --mirror Aliyunsudo usermod -aG docker $USERdocker -v# 安装 nvidia-docker2curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-docker&#x2F;gpgkey | sudo apt-key add -distribution&#x3D;$(. &#x2F;etc&#x2F;os-release;echo $ID$VERSION_ID)curl -s -L https:&#x2F;&#x2F;nvidia.github.io&#x2F;nvidia-docker&#x2F;$distribution&#x2F;nvidia-docker.list | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;nvidia-docker.listsudo apt-get updatesudo apt-get install nvidia-docker2# 配置默认 nvidia runtimesudo vi &#x2F;etc&#x2F;docker&#x2F;daemon.json&#123; &quot;default-runtime&quot;: &quot;nvidia&quot;, &quot;runtimes&quot;: &#123; &quot;nvidia&quot;: &#123; &quot;path&quot;: &quot;&#x2F;usr&#x2F;bin&#x2F;nvidia-container-runtime&quot;, &quot;runtimeArgs&quot;: [] &#125; &#125;&#125;service docker restartdocker run --rm hello-world nvidia-smi","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"COCO dataset format","slug":"Others-20210106-COCO-dataset-format","date":"2021-01-06T11:28:43.000Z","updated":"2021-01-06T11:46:06.267Z","comments":true,"path":"2021/01/06/Others-20210106-COCO-dataset-format/","link":"","permalink":"http://example.com/2021/01/06/Others-20210106-COCO-dataset-format/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- annotations - &#x27;info&#x27;: dict - &#x27;licenses&#x27; list - &#x27;images&#x27; [ &#123; - &#x27;filename&#x27;: str - &#x27;id&#x27;: int - &#x27;height&#x27;: int - &#x27;width&#x27;: int - &#x27;flickr_url&#x27;: str - &#x27;license&#x27;: int - &#x27;coco_url&#x27;: str - &#x27;date_captured&#x27;: str &#125;, ... ... ] - &#x27;annotations&#x27; [ &#123; - &#x27;segmentation&#x27;: list - &#x27;num_keypoints&#x27;: int - &#x27;area&#x27;: float - &#x27;is_crowd&#x27;: bool - &#x27;keypoint&#x27;: - x1, y1, k1 # k=0 不可见未标注；k=1 不可见标注； k=2 可见标注 - x2, y2, k2 - ...... - &#x27;bbox&#x27;: list - ( x1, y1, w1, h1 ) - ( x2, y2, w2, h2 ) - ...... - &#x27;category_id&#x27;: int - &#x27;image_id&#x27;: int - &#x27;id&#x27;: int &#125;, ... ... ] - &#x27;categories&#x27;: [ &#123; - &#x27;id&#x27;: int - &#x27;keypoints&#x27;: - kpt-name1 - kpt-name2 - ... - &#x27;skeleton&#x27;: - (pair1_index1, pair1_index2) - (pair2_index1, pair2_index2) - ... - &#x27;name&#x27;: &#x27;person&#x27; - &#x27;supercategory&#x27;: &#x27;person&#x27; &#125; ]","categories":[{"name":"others","slug":"others","permalink":"http://example.com/categories/others/"}],"tags":[{"name":"COCO","slug":"COCO","permalink":"http://example.com/tags/COCO/"}]},{"title":"COCO dataset format","slug":"others-20210106-COCO-dataset-format","date":"2021-01-06T11:28:43.000Z","updated":"2021-01-06T11:46:06.267Z","comments":true,"path":"2021/01/06/others-20210106-COCO-dataset-format/","link":"","permalink":"http://example.com/2021/01/06/others-20210106-COCO-dataset-format/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- annotations - &#x27;info&#x27;: dict - &#x27;licenses&#x27; list - &#x27;images&#x27; [ &#123; - &#x27;filename&#x27;: str - &#x27;id&#x27;: int - &#x27;height&#x27;: int - &#x27;width&#x27;: int - &#x27;flickr_url&#x27;: str - &#x27;license&#x27;: int - &#x27;coco_url&#x27;: str - &#x27;date_captured&#x27;: str &#125;, ... ... ] - &#x27;annotations&#x27; [ &#123; - &#x27;segmentation&#x27;: list - &#x27;num_keypoints&#x27;: int - &#x27;area&#x27;: float - &#x27;is_crowd&#x27;: bool - &#x27;keypoint&#x27;: - x1, y1, k1 # k=0 不可见未标注；k=1 不可见标注； k=2 可见标注 - x2, y2, k2 - ...... - &#x27;bbox&#x27;: list - ( x1, y1, w1, h1 ) - ( x2, y2, w2, h2 ) - ...... - &#x27;category_id&#x27;: int - &#x27;image_id&#x27;: int - &#x27;id&#x27;: int &#125;, ... ... ] - &#x27;categories&#x27;: [ &#123; - &#x27;id&#x27;: int - &#x27;keypoints&#x27;: - kpt-name1 - kpt-name2 - ... - &#x27;skeleton&#x27;: - (pair1_index1, pair1_index2) - (pair2_index1, pair2_index2) - ... - &#x27;name&#x27;: &#x27;person&#x27; - &#x27;supercategory&#x27;: &#x27;person&#x27; &#125; ]","categories":[{"name":"others","slug":"others","permalink":"http://example.com/categories/others/"}],"tags":[{"name":"COCO","slug":"COCO","permalink":"http://example.com/tags/COCO/"}]},{"title":"Boxcars: 3d boxes as cnn input for improved fine-grained vehicle recognition","slug":"Paper-Notes-20210106-Boxcars-3d-boxes-as-cnn-input-for-improved-fine-grained-vehicle-recognition","date":"2021-01-06T06:10:48.000Z","updated":"2021-01-06T09:28:43.435Z","comments":true,"path":"2021/01/06/Paper-Notes-20210106-Boxcars-3d-boxes-as-cnn-input-for-improved-fine-grained-vehicle-recognition/","link":"","permalink":"http://example.com/2021/01/06/Paper-Notes-20210106-Boxcars-3d-boxes-as-cnn-input-for-improved-fine-grained-vehicle-recognition/","excerpt":"Boxcars: 3d boxes as cnn input for improved fine-grained vehicle recognition CVPR 2016 这篇文章提出了一种使用车辆 3D box 作为网络输入，来识别车型的方法。首先检测出车辆的 3D包围框，然后展开成 2D 图形，最后加入视角信息作为额外输入进行训练。同时还发布了一个新的数据集 BoxCars","text":"Boxcars: 3d boxes as cnn input for improved fine-grained vehicle recognition CVPR 2016 这篇文章提出了一种使用车辆 3D box 作为网络输入，来识别车型的方法。首先检测出车辆的 3D包围框，然后展开成 2D 图形，最后加入视角信息作为额外输入进行训练。同时还发布了一个新的数据集 BoxCars 3D 包围框：文中没有介绍获得车辆的 3D 包围框 的方法。这是作者之前的一个工作。Automatic camera calibration for traffic understanding 车辆图片平展：获得 3D 包围框后，将其展开成 2D 图像，具体方法类似于将立体的纸盒子在平面上铺开。很简单的一个思路。 车辆的视角信息：作者用三个向量来对车辆的视角信息进行编码。分别是 车尾-车头向量、车内-车外向量，车底-车顶向量。通过这三个向量，可以完整表示出车辆的视角。 栅格化包围框：作者同时提出另外一种方法描述车辆的视角。将车辆的矩形包围框中用四种颜色进行表示。其中 车顶用黄色，车侧用红色，车头/车尾同蓝色，其他位置用白色。这样一幅新的栅格化图像同样可以确定出车辆的视角。 平铺图 + 视角辅助信息 训练：平铺图直接进入 CNN 进行卷积操作；视角编码通过 6x6 的矩阵表示，使用三向量表示的情况下，矩阵的第一行表示 3 个二维向量，其他行用 0 填充；使用栅格化包围框表示的情况下，直接将 bbox rescale 成 6x6 的矩阵。文中只说 view encoding 是加在卷积操作之后，但是具体怎么加没有说明。 Bbox Cars 数据集：作者同时还公布了一个新的数据集，数据集中的图片是从道路车辆监控视频中获取的，主要特点就是包含了车辆的 3D box 信息。 实验结果：作者提出的方法需要数据集标注了车辆的 3D box 信息，具体怎么在 CompCars 数据集上做的实验阐述的不太清楚，下面是实验结果： top1 top5 baseline 0.767 0.917 ours 0.848 0.954","categories":[{"name":"Paper notes","slug":"Paper-notes","permalink":"http://example.com/categories/Paper-notes/"},{"name":"FGVC","slug":"Paper-notes/FGVC","permalink":"http://example.com/categories/Paper-notes/FGVC/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"FGVC","slug":"FGVC","permalink":"http://example.com/tags/FGVC/"}]},{"title":"A Large-Scale Car Dataset for Fine-grained Categotozation and Verification","slug":"Paper-Notes-20210106-A-Large-Scale-Car-Dataset-for-Fine-grained-Categotozation-and-Verification","date":"2021-01-06T06:10:34.000Z","updated":"2021-01-06T12:28:28.374Z","comments":true,"path":"2021/01/06/Paper-Notes-20210106-A-Large-Scale-Car-Dataset-for-Fine-grained-Categotozation-and-Verification/","link":"","permalink":"http://example.com/2021/01/06/Paper-Notes-20210106-A-Large-Scale-Car-Dataset-for-Fine-grained-Categotozation-and-Verification/","excerpt":"A Large-Scale Car Dataset for Fine-grained Categotozation and Verification CVPR 2015 这篇文章提出了一个大型的数据集 CompCars，里面包含了从网络上收集的 13.6w 张整车图片， 2.7w 张车辆局部图片，还有从监控场景下拍摄的 5k 张车辆正脸图片。 实验部分使用这个数据集分别用于 车辆细粒度分类、车辆属性所识别、车辆验证 三个任务。","text":"A Large-Scale Car Dataset for Fine-grained Categotozation and Verification CVPR 2015 这篇文章提出了一个大型的数据集 CompCars，里面包含了从网络上收集的 13.6w 张整车图片， 2.7w 张车辆局部图片，还有从监控场景下拍摄的 5k 张车辆正脸图片。 实验部分使用这个数据集分别用于 车辆细粒度分类、车辆属性所识别、车辆验证 三个任务。 CompCars 数据集： 品牌（Make）：163 车型（Model）：1716 年份（Year）：4455 整车图片数：136,727 F ：18431 R ：13513 S ：23551 FS：49301 RS：31150 局部图片数：27,618 outter part: headlight, rearlight, fog light, air intake inter part: console, steering wheel, dashboard, gear lever Fine-grained classification 数据集： 车型： 431 Train Test Total 图片数（整车） 16016 14939 30955 Baseline： model: overfeat dataset: Fine-grained classification result: view F R S FS RS all top1 0.524 0.431 0.428 0.563 0.598 0.767 top5 0.748 0.647 0.602 0.769 0.777 0.917 Make 0.701 0.521 0.507 0.680 0.656 0.829 单视角识别车型： RS 效果最好； 单视角识别品牌： F 效果最好； 多视角 Baseline： model: 0.767, make: 0.829 Supplementary experiment:在整个 CompCars 数据集上补充一个实验，比较三种模型的效果 | model | AlexNet | Overfeat | GoogLeNet | |- |- |- |- | | top1 | 0.819 | 0.879 | 0.912 | | top5 | 0.949 | 0.969 | 0.981 |","categories":[{"name":"Paper notes","slug":"Paper-notes","permalink":"http://example.com/categories/Paper-notes/"},{"name":"FGVC","slug":"Paper-notes/FGVC","permalink":"http://example.com/categories/Paper-notes/FGVC/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"FGVC","slug":"FGVC","permalink":"http://example.com/tags/FGVC/"}]},{"title":"Multi-Attention Multi-Class Constraint for Fine-grained Image Recognition","slug":"Paper-Notes-20210106-Multi-Attention-Multi-Class-Constraint-for-Fine-grained-Image-Recognition","date":"2021-01-06T05:54:07.000Z","updated":"2021-01-06T06:06:22.166Z","comments":true,"path":"2021/01/06/Paper-Notes-20210106-Multi-Attention-Multi-Class-Constraint-for-Fine-grained-Image-Recognition/","link":"","permalink":"http://example.com/2021/01/06/Paper-Notes-20210106-Multi-Attention-Multi-Class-Constraint-for-Fine-grained-Image-Recognition/","excerpt":"Multi-Attention Multi-Class Constraint for Fine-grained Image Recognition arxiv(Baidu) 这篇文章的思路是 attention + 度量学习。其中，attention 部分跟 SENet 如出一辙；度量学习比较像 contrastive loss。文章中定义了四种类型的特征，sasc, sadc, dasc, dadc, （s: same, a: attention, d: different, c: class），进行度量学习的时候，定义只有 sasc 是正样本，约束相同类别在相同attention区域学习到相似的特征。 在 CUB 数据集的准确率达到了 86.5。从 这篇文章 和 MSRA的WS-LAN 来看，attention + 度量学习 的方法是细粒度分类里面比较好的一个研究方向。","text":"Multi-Attention Multi-Class Constraint for Fine-grained Image Recognition arxiv(Baidu) 这篇文章的思路是 attention + 度量学习。其中，attention 部分跟 SENet 如出一辙；度量学习比较像 contrastive loss。文章中定义了四种类型的特征，sasc, sadc, dasc, dadc, （s: same, a: attention, d: different, c: class），进行度量学习的时候，定义只有 sasc 是正样本，约束相同类别在相同attention区域学习到相似的特征。 在 CUB 数据集的准确率达到了 86.5。从 这篇文章 和 MSRA的WS-LAN 来看，attention + 度量学习 的方法是细粒度分类里面比较好的一个研究方向。 OSME (One-Squeeze Multi-Excitation Attention Module)：这一部分，按照我的理解，可以说是完全照搬的 SENet，没有任何创新点。作者说明了 SENet 中 SE module 的原理。文中提出的网络结构，将提取到的特征，分别经过两个 SE module，得到的两个 re-weighted feature map，称为 attention1， attention2.我理解的 OSME module 与 SE module 的区别就是一个是单路的，一个是双路的。 Multi-Attention Multi-Class Constraint：这一部分，作者使用了度量学习的方法，每次训练的时候，网络会输入 2N 对图片，其中每一对图片都来自于同一类别。然后一对图片分别经过 OSME 的上半支和下半支，这样可以得到四种类别的特征。sasc, sadc, dasc, dadc，在 softmax 的基础上，作者对 hinge loss 进行改进，提出 MAMC Constraint，四种特征。挑选出一个特征作为 anchor，然后分三种情况： 正样本是 sasc， 负样本是 {sadc, dasc, dadc}; 正样本是 sadc， 负样本是 {dadc}; 正样本是 dasc， 负样本是 {dadc};在每种情况下，定义出 MAMC loss，最小化与正样本的特征距离，最大化与负样本的特征距离。 实验结果： acc VGG19 79.0 ResNet50 81.7 ResNet101 82.5 ResNet-50 + OSME 84.9 ResNet-50 + OSME + MAMC_1 85.4 ResNet-50 + OSME + MAMC 86.2 ResNet-50 + OSME_3 + MAMC 86.3 ResNet-101 + OSME + MAMC 86.5 RACNN 85.3 MACNN 86.5 OSME_3: 使用 3 个 attentionMAMC_1：定义 MAMC loss 的时候，只区分第一种情况。 使用 ResNet50 作为 backbone， OSME 提升了 3.2%， MAMC 提升了 1.3% 的准确率。值得一提的是，相比于 MACNN，文中提出的网络结构要简单的多，在效率上具有很大的优势。","categories":[{"name":"Paper notes","slug":"Paper-notes","permalink":"http://example.com/categories/Paper-notes/"},{"name":"FGVC","slug":"Paper-notes/FGVC","permalink":"http://example.com/categories/Paper-notes/FGVC/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"FGVC","slug":"FGVC","permalink":"http://example.com/tags/FGVC/"}]},{"title":"Fine-grained Image Classification by Visual-Semantic Embedding","slug":"Paper-Notes-20210106-Fine-grained-Image-Classification-by-Visual-Semantic-Embedding","date":"2021-01-06T05:53:57.000Z","updated":"2021-01-06T06:06:54.889Z","comments":true,"path":"2021/01/06/Paper-Notes-20210106-Fine-grained-Image-Classification-by-Visual-Semantic-Embedding/","link":"","permalink":"http://example.com/2021/01/06/Paper-Notes-20210106-Fine-grained-Image-Classification-by-Visual-Semantic-Embedding/","excerpt":"Fine-grained Image Classification by Visual-Semantic Embedding IJCAI 2018 这篇文章的创新点是利用到了细粒度分类中子类别的语义信息。文中提到了两种语义信息，一种是 text context，以 CUB 数据集为例，wiki 上对某一子类鸟的描述就是 text context；另一种是 knowledge based context，收集子类鸟的各种属性，建立知识库，有点属性学习的意思。 这篇文章的想法很有创新，并且也有很好的效果，在 CUB 数据集上达到 86.2 的准确率。但是没有验证在其他数据集上是否同时有效。","text":"Fine-grained Image Classification by Visual-Semantic Embedding IJCAI 2018 这篇文章的创新点是利用到了细粒度分类中子类别的语义信息。文中提到了两种语义信息，一种是 text context，以 CUB 数据集为例，wiki 上对某一子类鸟的描述就是 text context；另一种是 knowledge based context，收集子类鸟的各种属性，建立知识库，有点属性学习的意思。 这篇文章的想法很有创新，并且也有很好的效果，在 CUB 数据集上达到 86.2 的准确率。但是没有验证在其他数据集上是否同时有效。 Two leval CNN:作者设计了一个双层的网络结构，F(a) 是定位网络，F(b) 是回归排序网络，网络结构图参考论文。 Localization Network：这一部分是传统的目标检测网络模型。提取 定位网络的特征，与回归网络提取的特征点乘，起到 Attention 的作用。 Regression Ranking Network：这一部分通过 CNN 提取网络的特征，然后加入定位网络提取的特征作为 Attention，得到视觉特征，接下来通过 FC 层，将视觉特征映射到语义空间，网络的约束条件就是特征在语义空间中的距离，优化网络，减小学习到的语义特征与 gt 在语义空间中的特征距离。作者使用了两种语义空间，因此网络的视觉特征同时平行通过了两个 FC 层。 Knowledge Base Embedding：这里参考了 Learning Entity and Relation Embeddings for Knowledge Graph Completion 中提出的 TransR 方法。并在此基础上针对细粒度分类问题提出了 Attribute Base Embedding。这一部分属于 知识图谱 的领域，看得不是很明白。首先，传统的 知识库嵌入 中，知识库由 三元组(h, r, t) 组成，其中 h，t 表示两个实体，h 是起点，t 是终点；r 表示是实体之间的关系。实体(h,t) 由 d 维数组表示，关系(r) 由 r 维数组表示，映射矩阵 M(r) 是一个 d*r 的矩阵，将实体空间映射到关系空间。知识图谱的约束条件定义为：f(h, t) = ||h(r) + r - t(r) ||。基于 知识库嵌入 改进的 属性知识库嵌入，三元组(h, r, t)中 实体h 是样本标签y， 关系r 是 has_property_of， 实体t 是样本的属性。通过优化映射矩阵，将样本标签映射到 属性知识库空间。 Text Embedding：文本嵌入部分通过 word2vec 实现。作者首先 finetune 了一个 word2vec 模型，然后利用模型将 类别名称 映射到 文本语义空间。 实验结果：作者在 CUB 数据集上做的实验，按照论文所述，训练的过程中既没有使用 bbox 信息，也没有使用 part annotation 信息，这一点不是很明白，和我理解的训练过程不太一样。 CUB 准确率： 0.862","categories":[{"name":"Paper notes","slug":"Paper-notes","permalink":"http://example.com/categories/Paper-notes/"},{"name":"FGVC","slug":"Paper-notes/FGVC","permalink":"http://example.com/categories/Paper-notes/FGVC/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"FGVC","slug":"FGVC","permalink":"http://example.com/tags/FGVC/"}]},{"title":"Fine-Grained Image Classification Using Modified DCNNs Trained by Cascaded Softmax and Generalized Large-Margin Losses","slug":"Paper-Notes-20210106-Fine-Grained-Image-Classification-Using-Modified-DCNNs-Trained-by-Cascaded-Softmax-and-Generalized-Large-Margin-Losses","date":"2021-01-06T05:53:45.000Z","updated":"2021-01-06T06:06:51.075Z","comments":true,"path":"2021/01/06/Paper-Notes-20210106-Fine-Grained-Image-Classification-Using-Modified-DCNNs-Trained-by-Cascaded-Softmax-and-Generalized-Large-Margin-Losses/","link":"","permalink":"http://example.com/2021/01/06/Paper-Notes-20210106-Fine-Grained-Image-Classification-Using-Modified-DCNNs-Trained-by-Cascaded-Softmax-and-Generalized-Large-Margin-Losses/","excerpt":"Fine-Grained Image Classification Using Modified DCNNs Trained by Cascaded Softmax and Generalized Large-Margin Losses TNNLS 2018 这篇文章提出了两个创新点，一个是 级联softmax结构，另一个是 泛化 large-margin loss。主要的思想就是细粒度分类中的标签是具有层次结构的，large-margin loss 是度量学习中提出的概念，这里在细粒度分类问题中进行了改进。 文章摆了大量的公式，所以我是没怎么仔细看的，并且它的结果并不很出色。使用 VGG 作为 backbone，在 CUB 上准确率是 77.0，结合 bilinear-CNN，从 84.1 提升到了 85.4","text":"Fine-Grained Image Classification Using Modified DCNNs Trained by Cascaded Softmax and Generalized Large-Margin Losses TNNLS 2018 这篇文章提出了两个创新点，一个是 级联softmax结构，另一个是 泛化 large-margin loss。主要的思想就是细粒度分类中的标签是具有层次结构的，large-margin loss 是度量学习中提出的概念，这里在细粒度分类问题中进行了改进。 文章摆了大量的公式，所以我是没怎么仔细看的，并且它的结果并不很出色。使用 VGG 作为 backbone，在 CUB 上准确率是 77.0，结合 bilinear-CNN，从 84.1 提升到了 85.4 Cascaded Softmax Loss：级联softmax，见文中的 插图3，其实是一个很简单的结构，假设识别任务中有 50 个粗分类，每个分类中有 4 个细分类，总共 200 分类。传统的网络，直接通过 fc8(200)+softmax 进行训练，这里改成了 fc8(200)+ softmax + fc9(50)+softmax 训练，并且在 fc7 和 fc(9) 之间添加了一个 skip connection. 网络的 loss 则变成了每一层 softmax 的 loss 相加。 Generalized Large-Margin Loss：泛化 large-margin loss，这个用起来其实也很简单，就是在 fc7 添加一个 loss层 进行监督，large-margin loss 的作用就是增加类间距离，减小类内距离，在标签具有分层结构的情况下，对每个 level 的标签都进行这样的约束，这一部分文中使用了大量的公式，没有仔细看。 实验结果：作者的这个改动可以应用到任何 CNN 结构中，所以作者做了大量的实验： w/o bbox with bbox googlenet+SM 73.6 77.4 googlenet+CSM 74.6 78.4 googlenet+SC+CSM 75.3 79.0 googlenet+SM+GLM 76.8 80.5 googlenet+CSM+GLM 77.1 81.3 googlenet+SC+CSM+GLM 77.6 82.0 VGG+SM 72.5 78.6 VGG+SC+CSM+GLM 77.0 82.4 B-CNN 84.1 84.8 B-CNN+SC+CSM+GLM 85.4 85.7 googlenet+SM+contrastive 74.1 77.8 googlenet+SM+triplet 74.1 78.0 googlenet+SM+center loss 74.5 78.4 googlenet+SM+min-max 75.1 78.9 SM: softmaxCSM: cascaded softmaxSC: skip connectionGLM: generlized large-margin loss 通过对比可以看出： GLM 对结果的影响是最大的， 76.8 单独 CSM 的效果并不明显，加上 SC 后还能提高一下。 74.6 -&gt; 75.3 在 VGG， googlenet 上有明显的提高，但是在 B-CNN 上的提高就比较小了。 GLM 相对于其他的 度量学习 方法效果也是最好的。","categories":[{"name":"Paper notes","slug":"Paper-notes","permalink":"http://example.com/categories/Paper-notes/"},{"name":"FGVC","slug":"Paper-notes/FGVC","permalink":"http://example.com/categories/Paper-notes/FGVC/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"FGVC","slug":"FGVC","permalink":"http://example.com/tags/FGVC/"}]},{"title":"Weakly Supervised Local Attention Network for Fine-Grained Visual Classification","slug":"Paper-Notes-20210106-Weakly-Supervised-Local-Attention-Network-for-Fine-Grained-Visual-Classification","date":"2021-01-06T05:53:32.000Z","updated":"2021-01-06T06:06:35.915Z","comments":true,"path":"2021/01/06/Paper-Notes-20210106-Weakly-Supervised-Local-Attention-Network-for-Fine-Grained-Visual-Classification/","link":"","permalink":"http://example.com/2021/01/06/Paper-Notes-20210106-Weakly-Supervised-Local-Attention-Network-for-Fine-Grained-Visual-Classification/","excerpt":"Weakly Supervised Local Attention Network for Fine-Grained Visual Classification arxiv (MSRA) 这篇文章提出一种 LAP(Local Attention Pooling) 的机制，利用 attention map 去提取更具区分性的特征图；文中还提出一种弱监督的方式去训练网络的方法，在训练过程中加入了 attention dropout 和 attention center loss。 文中提出的网络 WS-LAN(Weakly Supervised Local Attention Network)在 CUB 数据集上准确率达到了 87.9","text":"Weakly Supervised Local Attention Network for Fine-Grained Visual Classification arxiv (MSRA) 这篇文章提出一种 LAP(Local Attention Pooling) 的机制，利用 attention map 去提取更具区分性的特征图；文中还提出一种弱监督的方式去训练网络的方法，在训练过程中加入了 attention dropout 和 attention center loss。 文中提出的网络 WS-LAN(Weakly Supervised Local Attention Network)在 CUB 数据集上准确率达到了 87.9 Local Attention Pooling:这一部分通过文中的 插图1 很容易就能看懂。作者首先通过 CNN 分别提取到图片的 特征图 和 注意力图，其中每一个注意力图用于聚焦目标的一个 part 上。然后将特征图与 k 个注意力图分别点乘，得到 k 个 part 的特征图。对 k 个特征图进行卷积核池化操作，得到每一个 part 的特征，将 k 个 part 特征合并到一起形成最终的特征。这一部分实际上与 SE-Net 很相似。SE-Net 将特征经过卷积之后，再经过一个 SE 结构，等同于在卷积过程中对卷积核的不同 channel 赋予不同的权重，上一层的特征会分别与卷积核的不同 channel 进行卷积操作。假设将上一层特征看做 LAN 中的特征图，channel间 attention 最大的 topk 个卷积核看做 LAN 中的注意力图，那么两个网络的区别就是一个是进行 卷积操作，一个是进行 点乘操作。所以这一部分实际上可以看做是一个稍加改动，更为复杂的 SE-Net。但是这种改动是必要的，因为下面的 WS-LAN 需要在这个网络结构上进行训练。 WS-LAN：这一部分，作者将两个传统网络训练中的 trick 迁移到了上面的 LAN 中，这应该是文章最大的两个提升点。这部分的两个 trick 实际上想解决的问题只有一个，就是 提取到的 attention map 很容易只聚焦到目标的一两个最具区分度的区域。 attention dropout：作者将 dropout 加入到 LAP 操作中。attention map 和 feature map 进行点乘的时候，attention map 以 概率(1-p) 被 drop 掉，以概率 p 被保留，并乘以 1/p，这个操作与传统的 dropout 如出一辙。 attention center loss：人脸识别文章中提出过一个 center loss，作者同样将其迁移到 WS-LAN 中。attention map 与 feature map 点乘之后得到 k 个 part feature，作者为这 k 个 feature 维护 k 个 center，然后每次训练的时候，计算每个 feature 和 center 的距离，最小化同一个 part 的 feature distance，最大化不同 part 的 feature distance，作为 attention center loss 的约束条件。 实验结果： acc LAN 85.5 WS-LAN 87.9","categories":[{"name":"Paper notes","slug":"Paper-notes","permalink":"http://example.com/categories/Paper-notes/"},{"name":"FGVC","slug":"Paper-notes/FGVC","permalink":"http://example.com/categories/Paper-notes/FGVC/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"FGVC","slug":"FGVC","permalink":"http://example.com/tags/FGVC/"}]},{"title":"Embedding label structures for fine-grained feature representation","slug":"Paper-Notes-20210106-Embedding-label-structures-for-fine-grained-feature-representation","date":"2021-01-06T05:53:11.000Z","updated":"2021-01-06T06:06:58.769Z","comments":true,"path":"2021/01/06/Paper-Notes-20210106-Embedding-label-structures-for-fine-grained-feature-representation/","link":"","permalink":"http://example.com/2021/01/06/Paper-Notes-20210106-Embedding-label-structures-for-fine-grained-feature-representation/","excerpt":"Embedding label structures for fine-grained feature representation CVPR 2016 这篇文章提出两个创新点，一个是使用 “structured label” 改进 triple loss；另一个是同时使用 triple loss 和 softmax loss 进行训练。","text":"Embedding label structures for fine-grained feature representation CVPR 2016 这篇文章提出两个创新点，一个是使用 “structured label” 改进 triple loss；另一个是同时使用 triple loss 和 softmax loss 进行训练。 同时使用 softmax loss 和 triple loss 约束训练：这个没什么好说的，一个很简单的想法。使用三路的网络，提取特征，然后分为两支，一支过 fc+softmax 然后分类，一支对比 anchor, positive, negative 的特征距离，然后用 triple loss 进行约束。网络结果参照论文链接。 结构化目标嵌入（embed label structures）:这一部分是对 triple loss 的一个改进，在细粒度分类问题中，目标的分类可以看做层级的，以车辆分类为例，目标结构由粗到细可以是 品牌-模型-年份，因此做模型分类的时候，可以使用四元组进行训练：r(reference), p+(same model), p-(same make, diffrent model), n(diffrent make)，四元组的 loss 等价于 L(r, p+, p-) + L(r, p-, n)。 实验结果：作者在 standFord Cars 上面进行实验，实验结果略（笔记只记录 CUB 数据集的结果）","categories":[{"name":"Paper notes","slug":"Paper-notes","permalink":"http://example.com/categories/Paper-notes/"},{"name":"FGVC","slug":"Paper-notes/FGVC","permalink":"http://example.com/categories/Paper-notes/FGVC/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"FGVC","slug":"FGVC","permalink":"http://example.com/tags/FGVC/"}]},{"title":"The unreasonable effectiveness of noisy data for fine-grained recognition","slug":"Paper-Notes-20210106-The-unreasonable-effectiveness-of-noisy-data-for-fine-grained-recognition","date":"2021-01-06T05:46:06.000Z","updated":"2021-01-06T06:06:30.316Z","comments":true,"path":"2021/01/06/Paper-Notes-20210106-The-unreasonable-effectiveness-of-noisy-data-for-fine-grained-recognition/","link":"","permalink":"http://example.com/2021/01/06/Paper-Notes-20210106-The-unreasonable-effectiveness-of-noisy-data-for-fine-grained-recognition/","excerpt":"The unreasonable effectiveness of noisy data for fine-grained recognition ECCV 2016 这篇文章提出使用网络爬取的数据进行细粒度分类任务。与其说是提出一种新的方法，不如说是新建了一个数据集。 网络爬取的图片并不完全准确，因此讨论了对这些噪声的处理方法。 加入大量网络数据后，训练的效果得到了大幅度的提升，目前在 CUB 数据集上准确率达到了 92.3","text":"The unreasonable effectiveness of noisy data for fine-grained recognition ECCV 2016 这篇文章提出使用网络爬取的数据进行细粒度分类任务。与其说是提出一种新的方法，不如说是新建了一个数据集。 网络爬取的图片并不完全准确，因此讨论了对这些噪声的处理方法。 加入大量网络数据后，训练的效果得到了大幅度的提升，目前在 CUB 数据集上准确率达到了 92.3 cross-domain noise:cross-domain noise 指的是不属于这一大类的图片，例如搜索某种鸟，出来的结果是昆虫的图片。通过人工标注量化了这种噪声，发现这种情况比较少，并且当图片数目增多的时候，噪声占的比例也会减少。这种噪声对结果的影响也比较小。 cross-category noise:cross-category noise 指的是将其他子类的图片混入搜索结果的情况。这种噪声的比例难以量化，并且对结果的影响比较大，作者将搜索结果中重复的图片去除掉来减少这些噪声。 active learning：作者还提出两种标注方法辅助去除噪声。1）使用预训练好的模型，挑选搜索结果中置信度高的结果；2）人工筛选搜索结果。 实验结果： CUB web-raw web-filter L-bird L-bird(MC) L-bird+CUB L-bird+CUB(MC) acc 84.4 87.7 89.0 91.9 92.3 92.2 92.8 `CUB`：CUB 数据集 `web-raw`：web 爬取数据集 `web-filter`： 去除 `cross-category noise` `L-Bird`: 爬取所有鸟类的图片，进行预训练，然后在 web-filter 上 finetune `MC`：测试的时候使用 multi-crop","categories":[{"name":"Paper notes","slug":"Paper-notes","permalink":"http://example.com/categories/Paper-notes/"},{"name":"FGVC","slug":"Paper-notes/FGVC","permalink":"http://example.com/categories/Paper-notes/FGVC/"}],"tags":[{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"FGVC","slug":"FGVC","permalink":"http://example.com/tags/FGVC/"}]},{"title":"hexo installation","slug":"hexo-20210106-hexo-installation","date":"2021-01-06T01:32:59.000Z","updated":"2021-01-06T06:08:35.376Z","comments":true,"path":"2021/01/06/hexo-20210106-hexo-installation/","link":"","permalink":"http://example.com/2021/01/06/hexo-20210106-hexo-installation/","excerpt":"1. 安装 git, node.js, Hexo 参考 Hexo 官方教程 2. 添加 github pages 新建 github repository 新建 hexo 分支，并设置为默认分支 添加 ssh hey 12ssh-keygen -t rsacat .ssh\\id_rsa.pub 在 settings -&gt; SSH and GPG keys -&gt; New SSH key 里面添加公钥。 新建 hexo 博客 123git clone clover978.github.iohexo init clover978.github.ionpm install hexo-deployer-git --save 在 clover978.github.io/_config.yml 里设置如下字段： 1234deploy:type: &#39;git&#39;repo: https:&#x2F;&#x2F;github.com&#x2F;clover978&#x2F;clover978.github.iobranch: master","text":"1. 安装 git, node.js, Hexo 参考 Hexo 官方教程 2. 添加 github pages 新建 github repository 新建 hexo 分支，并设置为默认分支 添加 ssh hey 12ssh-keygen -t rsacat .ssh\\id_rsa.pub 在 settings -&gt; SSH and GPG keys -&gt; New SSH key 里面添加公钥。 新建 hexo 博客 123git clone clover978.github.iohexo init clover978.github.ionpm install hexo-deployer-git --save 在 clover978.github.io/_config.yml 里设置如下字段： 1234deploy:type: &#39;git&#39;repo: https:&#x2F;&#x2F;github.com&#x2F;clover978&#x2F;clover978.github.iobranch: master 3. 安装 theme1git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next 4. 其他设置 参考 _config.yml 和 themes/next/_config.yml 里的各种字段，设置页面布局。 5. 发布 blog 编写 blog1234hexo new &lt;title&gt;# 编辑 _post 里面生成 md 文件hexo ghexo d 同步 hexo 123git add .git commit -m &quot;add new blog&quot;git push","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}],"categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"C++","slug":"C","permalink":"http://example.com/categories/C/"},{"name":"Caffe","slug":"Caffe","permalink":"http://example.com/categories/Caffe/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://example.com/categories/TensorFlow/"},{"name":"Caffe2","slug":"Caffe2","permalink":"http://example.com/categories/Caffe2/"},{"name":"Pytorch","slug":"Pytorch","permalink":"http://example.com/categories/Pytorch/"},{"name":"others","slug":"others","permalink":"http://example.com/categories/others/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"Paper notes","slug":"Paper-notes","permalink":"http://example.com/categories/Paper-notes/"},{"name":"FGVC","slug":"Paper-notes/FGVC","permalink":"http://example.com/categories/Paper-notes/FGVC/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"动态链接库","slug":"动态链接库","permalink":"http://example.com/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"混合编程","slug":"混合编程","permalink":"http://example.com/tags/%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B/"},{"name":"argparser","slug":"argparser","permalink":"http://example.com/tags/argparser/"},{"name":"多线程","slug":"多线程","permalink":"http://example.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"deep learning","slug":"deep-learning","permalink":"http://example.com/tags/deep-learning/"},{"name":"Action Recgnition","slug":"Action-Recgnition","permalink":"http://example.com/tags/Action-Recgnition/"},{"name":"Caffe","slug":"Caffe","permalink":"http://example.com/tags/Caffe/"},{"name":"LMDB","slug":"LMDB","permalink":"http://example.com/tags/LMDB/"},{"name":"Object Detection","slug":"Object-Detection","permalink":"http://example.com/tags/Object-Detection/"},{"name":"Faster RCNN","slug":"Faster-RCNN","permalink":"http://example.com/tags/Faster-RCNN/"},{"name":"Pose Estimation","slug":"Pose-Estimation","permalink":"http://example.com/tags/Pose-Estimation/"},{"name":"OpenPose","slug":"OpenPose","permalink":"http://example.com/tags/OpenPose/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://example.com/tags/TensorFlow/"},{"name":"Caffe2","slug":"Caffe2","permalink":"http://example.com/tags/Caffe2/"},{"name":"Pytorch","slug":"Pytorch","permalink":"http://example.com/tags/Pytorch/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"Git","slug":"Git","permalink":"http://example.com/tags/Git/"},{"name":"OCR","slug":"OCR","permalink":"http://example.com/tags/OCR/"},{"name":"COCO","slug":"COCO","permalink":"http://example.com/tags/COCO/"},{"name":"FGVC","slug":"FGVC","permalink":"http://example.com/tags/FGVC/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]}